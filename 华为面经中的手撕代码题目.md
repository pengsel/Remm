# åä¸ºé¢ç»ä¸­çš„æ‰‹æ’•ä»£ç é¢˜ç›®

ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œç¬¬ä¸€ä¸ªå»æ‰å“ªäº›å­—ç¬¦åï¼Œå®ƒçš„å­å­—ç¬¦ä¸²èƒ½å’Œå¦ä¸€ä¸ªåŒ¹é…ã€‚

åŒæŒ‡é’ˆï¼ŒæŒ‰å­—ç¬¦åŒ¹é…ã€‚



æœ‰æ€»é¢ç§¯æ˜¯N*Nçš„å²›å’Œæµ·æ´‹ä¸¤ç§åœ°å½¢ï¼Œ1è¡¨ç¤ºå²›ï¼Œ0æ˜¯æµ·ã€‚é—®è·ç¦»å²›å±¿æœ€è¿œçš„æµ·æ´‹æ˜¯å“ªä¸ªï¼Œè·ç¦»æ˜¯å¤šå°‘ï¼Ÿè·ç¦»ç”¨ä»€ä¹ˆå…¬å¼ï¼ˆå¿˜äº†åå­—ï¼‰= |  x0-x1| + |y0-y1  | 

  ä¾‹å­1 

  1 0 1 

  0 0 0 

  1 0 1 

  æµ·æ´‹ä½ç½®å°±æ˜¯ï¼ˆ1,1ï¼‰ï¼Œè·ç¦»ä¸º2 

  


  ä¾‹å­2 

  1 0 0 

  0 0 0 

  0 0 0 

  æµ·æ´‹ä½ç½®å°±æ˜¯ï¼ˆ2,2ï¼‰è·ç¦»æ˜¯4

```java
int[][] directions = new int[][] {{-1, 0},{1,0},{0,-1},{0,1}};
public int maxDistance(int[][] grid) {
    if(grid == null || grid.length == 0 || grid[0].length == 0)return -1;
    boolean[][] visited = new boolean[grid.length][grid[0].length];
    Queue<int[]> queue = new ArrayDeque<>();

    for(int i = 0 ; i < grid.length ; i++) {
        for(int j = 0 ; j < grid[0].length ; j++) {
            //æ‰€æœ‰çš„å²›å±¿éƒ½å…¥é˜Ÿåˆ—
            if(grid[i][j] == 1) {
                queue.offer(new int[]{i,j});
                visited[i][j] = true;
            }
        }
    }
    //å½“æœ€ç»ˆæ‰€æœ‰çš„æµ·æ´‹éƒ½è¢«visitedæ—¶ï¼Œé˜Ÿåˆ—ä¸­ä»ç„¶ä¼šåŒ…å«å…ƒç´ ï¼Œå¤šè¿è¡Œä¸€è½®ï¼Œä¸ºäº†å¹³è¡¡æ‰€ä»¥levelåˆå§‹åŒ–ä¸º1ã€‚
    int level = -1;
    while(!queue.isEmpty()) {
        int size = queue.size();
        for(int i = 0 ; i < size ; i++) {
            //ä»å½“å‰é˜Ÿåˆ—å‡ºé˜Ÿä¸€ä¸ª
            int[] start = queue.poll();
            int x = start[0];
            int y = start[1];
            //éå†å®ƒçš„å››å‘¨æœ‰æ²¡æœ‰æµ·æ´‹
            for(int[] dir : directions) {
                int newX = x + dir[0];
                int newY = y + dir[1];
                //æ²¡æœ‰è¶…è¿‡è¾¹ç•Œï¼Œä¸”æµ·æ´‹æœªè¢«visited
                if(newX >= 0 && newX < grid.length && newY >= 0 && newY < grid[0].length
                        && !visited[newX][newY] && grid[newX][newY] == 0) {
                    //ç½®ä¸ºvisited
                    visited[newX][newY] = true;
                    //æ–°çš„ç‚¹visited
                    queue.offer(new int[]{newX, newY});
                }
            }
        }
        //æ‰€æœ‰å·²visitedçš„æµ·æ´‹ æˆ–è€… å²›å±¿ éƒ½æœå‘¨å›´çš„ æœªæ¢ç´¢çš„æµ·æ´‹ è¿ˆè¿›äº†ä¸€æ­¥ï¼Œlevel++ï¼›
        level++;
    }
    return level <= 0 ? -1 : level;
}
```



ä»£ç :ä¸‰æ•°ä¹‹å’Œï¼Œæ—¶é—´å¤æ‚åº¦   ä»£ç é¢˜ç›®ï¼šä»ä¸€ä¸²æ•°å­—ä¸­æ‰¾å‡ºæ‰€æœ‰çš„ç›¸åŠ ä¸º0çš„ä¸‰ä¸ªæ•°å­—ã€‚

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    if (nums==null||nums.length==0){
        return list;
    }
    Arrays.sort(nums);

    for (int i=0; i<nums.length-2; i++){

        if (i==0||(i>0&&nums[i]!=nums[i-1])) {
            int lo = i + 1, hi = nums.length - 1, sum = -nums[i];

            while (lo < hi) {
                if (sum == nums[lo] + nums[hi]) {
                    list.add(Arrays.asList(nums[i], nums[lo], nums[hi]));
                    while (lo < hi && nums[lo] == nums[lo + 1]) lo++;
                    while (lo < hi && nums[hi] == nums[hi - 1]) hi--;
                    lo++;
                    hi--;
                } else {
                    if (sum < nums[lo] + nums[hi]) hi--;
                    else lo++;
                }
            }
        }
    }


    return list;
}
```

æ‰‹æ’•åˆ¤æ–­äºŒå‰æ ‘æ˜¯å¦ç›¸ç­‰

```java
public boolean sameTree(TreeNode p, TreeNode q){
    if (p==null && q==null) return true;
    if (p == null || q == null) return false;
    if (p.val!=q.val) return false;

    return sameTree(p.left,q.left)&&sameTree(p.right,q.right);
}
```



æ‰‹æ’•ä»£ç ï¼Œæœºè¯•æœ€åä¸€é¢˜

```java
private static int[][] dirs ={{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};

public static int shortestPathBinaryMatrix(int[][] grid) {

    if (grid==null||grid.length==0||grid[0].length==0){
        return -1;
    }

    if (grid.length==1 && grid[0].length==1){
        return 1;
    }

    if (grid[0][0]==1 || grid[grid.length-1][grid[0].length-1]== 1) {
        return -1;
    }



    boolean[][] visited = new boolean[grid.length][grid[0].length];
    int[][] path= new int[grid.length][grid[0].length];
    for (int i=0; i<grid.length;i++){
        for (int j=0; j<grid[0].length; j++){
            if (grid[i][j] ==1){
                visited[i][j] = true;
            }
        }
    }

    Queue queue = new LinkedList();
    queue.offer(new int[]{0,0});
    visited[0][0]=true;
    int level=1;
    boolean deadCircle=true;
    while (!queue.isEmpty()){
        int size=queue.size();
        for (int k=0; k < size; k++){
            int[] pos = (int[]) queue.poll();
            int x=pos[0];
            int y=pos[1];
            for (int[] dir: dirs){
                int newX=x+dir[0];
                int newY=y+dir[1];
                if (newX>=0 && newX < grid.length && newY>=0 && newY< grid[0].length){

                    if (newX == grid.length-1 && newY == grid[0].length-1){



                        path[newX][newY] = x*grid[0].length+y;

                        int i=grid.length-1,j=grid[0].length-1;
                        StringBuilder sb= new StringBuilder();
                        int posNum;
                        while ((i+j)!=0){
                            sb.insert(0,String.format("->(%s,%s)",i,j));
                            posNum=path[i][j];
                            i=posNum/grid[0].length;
                            j=posNum%grid[0].length;
                        }
                        sb.insert(0, String.format("(%s,%s)", i,j));
                        System.out.println(sb);




                        return level+1;
                    }

                    if (visited[newX][newY] == false) {
                        queue.offer(new int[]{newX, newY});
                        visited[newX][newY] = true;
                        path[newX][newY] = x*grid[0].length+y;
                        deadCircle=false;
                    }
                }
            }
        }

        if (deadCircle){
            return -1;
        }
        deadCircle=true;

        level++;
    }


    return -1;
}

```

å†™ä¸€ä¸ªè‡ªå·±æœ€ç†Ÿæ‚‰çš„ä»£ç ï¼Ÿæœ‰å“ªäº›ç”¨é€”ï¼Ÿ

æœ€ç®€å•çš„NIOæœåŠ¡å™¨

```java
System.out.println ("Listening on port " + port);

// allocate an unbound server socket channel
ServerSocketChannel serverChannel = ServerSocketChannel.open();
// Get the associated ServerSocket to bind it with
ServerSocket serverSocket = serverChannel.socket();
// create a new Selector for use below
Selector selector = Selector.open();

// set the port the server channel will listen to
serverSocket.bind (new InetSocketAddress (port));

// set non-blocking mode for the listening socket
serverChannel.configureBlocking (false);

// register the ServerSocketChannel with the Selector
serverChannel.register (selector, SelectionKey.OP_ACCEPT);

while (true) {
   // this may block for a long time, upon return the
   // selected set contains keys of the ready channels
   int n = selector.select();

   if (n == 0) {
      continue;  // nothing to do
   }

   // get an iterator over the set of selected keys
   Iterator it = selector.selectedKeys().iterator();

   // look at each key in the selected set
   while (it.hasNext()) {
      SelectionKey key = (SelectionKey) it.next();

      // Is a new connection coming in?
      if (key.isAcceptable()) {
         ServerSocketChannel server =
            (ServerSocketChannel) key.channel();
         SocketChannel channel = server.accept();

         registerChannel (selector, channel,
            SelectionKey.OP_READ);

         sayHello (channel);
      }

      // is there data to read on this channel?
      if (key.isReadable()) {
         readDataFromSocket (key);
      }

      // remove key from selected set, it's been handled
      it.remove();
   }
}
```

ä¸€ä¸Šæ¥ç›´æ¥å†™æ’åºï¼ˆä½†æ˜¯å†™é‚£ä¸ªè‡ªå·±å†³å®šï¼‰ï¼Œè¾¹èŠè¾¹å†™ï¼›

æ‰‹å†™å¿«é€Ÿæ’åºï¼Œåˆ†æå››æ¬¡è¿è¡Œæ’åºä¹‹åçš„æƒ…å†µ

å››æ¬¡è¿åŠ¨æ’åºï¼Œ

```java
    /**
     * å †æ’åºï¼š
     * 1.æ„å»ºä¸€ä¸ªå¤§é¡¶å †ï¼›
     * 2.é€æ­¥å°†æ¯ä¸ªæœ€å¤§å€¼çš„æ ¹ç»“ç‚¹ä¸æœ«å°¾å…ƒç´ äº¤æ¢ï¼Œå¹¶å†è°ƒæ•´å…¶æˆä¸ºå¤§é¡¶å †ã€‚
     * @param array
     */
    public static void heapSort(int[] array){
        int i;
        for (i=array.length/2-1;i>=0;i--){
            heapAdjust(array,i,array.length);
        }
        for (i=array.length-1;i>0;i--){
            swap(array,0,i);
            heapAdjust(array,0,i-1);
        }
    }
    private static void heapAdjust(int[] array, int nodeToAdjust,int maxIndex){
        int temp=array[nodeToAdjust];
//        å¯¹äºåˆå§‹åŒ–ä¸€ä¸ªå¤§é¡¶å †ï¼Œ
//        æ³¨æ„åˆ°åœ¨heapSortä¸­ä»length/2-1è¿™ä¸ªç»“ç‚¹å¼€å§‹å¾€æ ¹ç»“ç‚¹å®ç°å¤§é¡¶å †ï¼Œ
//        length/2-1æ˜¯ä¸€ä¸ªå¶å­ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œå¯¹äºè¿™æ ·çš„ç»“ç‚¹ï¼Œæ¬¡å‡½æ•°å¾ˆæ˜æ˜¾ä¼šæ»¡è¶³å®ç°ï¼›
//        åœ¨é€æ­¥å¾€æ ¹ç»“ç‚¹æ¨è¿›ï¼Œç›´åˆ°æ•´ä¸ªæ•°ç»„æ»¡è¶³ä¸€ä¸ªå¤§é¡¶å †ã€‚
//        å¯¹äºäº¤æ¢ç»“ç‚¹åé‡æ–°è°ƒæ•´ä¸ºå¤§é¡¶å †ï¼š
//        æ³¨æ„ï¼Œä¸åŒäºé‡æ–°æ„å»ºä¸€ä¸ªå¤§é¡¶å †ï¼Œå› ä¸ºé™¤äº†nodeToAdjustï¼Œå…¶ä»–ç»“ç‚¹éƒ½æ˜¯æ»¡è¶³å¤§é¡¶å †è¦æ±‚çš„ã€‚
//        çœ‹å­©å­ç»“ç‚¹æœ‰æ²¡æœ‰æ¯”å®ƒå¤§çš„ï¼Œå¦‚æœæ²¡æœ‰ï¼Œé€€å‡ºå¾ªç¯ï¼›å¦‚æœæœ‰ï¼ŒæŠŠå­©å­ç»“ç‚¹çš„å€¼èµ‹ç»™è¯¥ç»“ç‚¹ï¼Œå¹¶ä¸”å­©å­ç»“ç‚¹ç§°ä¸ºæ–°çš„éœ€è¦è°ƒæ•´çš„ç»“ç‚¹ã€‚
        for (int i=2*nodeToAdjust+1;i<=maxIndex;i=2*i+1){
            if (i<maxIndex&&array[i]<array[i+1]){
                i++;
            }
            if (temp>=array[i]){
                break;
            }
            array[nodeToAdjust]=array[i];
            nodeToAdjust=i;
        }
        array[nodeToAdjust]=temp;

    }


    /**
     * å½’å¹¶æ’åºï¼š
     * æ—¶é—´å¤æ‚åº¦ä¸ºO(nlogn)
     æœ€å¼€å§‹åªæ¯”è¾ƒä¸¤ä¸ªæ•°
     */
    public static void merSort(int[] arr,int left,int right){

        if(left<right){
            int mid = (left+right)/2;
            merSort(arr,left,mid);//å·¦è¾¹å½’å¹¶æ’åºï¼Œä½¿å¾—å·¦å­åºåˆ—æœ‰åº
            merSort(arr,mid+1,right);//å³è¾¹å½’å¹¶æ’åºï¼Œä½¿å¾—å³å­åºåˆ—æœ‰åº
            merge(arr,left,mid,right);//åˆå¹¶ä¸¤ä¸ªå­åºåˆ—
        }
    }
    private static void merge(int[] arr, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];//psï¼šä¹Ÿå¯ä»¥ä»å¼€å§‹å°±ç”³è¯·ä¸€ä¸ªä¸åŸæ•°ç»„å¤§å°ç›¸åŒçš„æ•°ç»„ï¼Œå› ä¸ºé‡å¤newæ•°ç»„ä¼šé¢‘ç¹ç”³è¯·å†…å­˜
        int i = left;
        int j = mid+1;
        int k = 0;
        while(i<=mid&&j<=right){
            if (arr[i] < arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        while(i<=mid){//å°†å·¦è¾¹å‰©ä½™å…ƒç´ å¡«å……è¿›tempä¸­
            temp[k++] = arr[i++];
        }
        while(j<=right){//å°†å³åºåˆ—å‰©ä½™å…ƒç´ å¡«å……è¿›tempä¸­
            temp[k++] = arr[j++];
        }
        //å°†tempä¸­çš„å…ƒç´ å…¨éƒ¨æ‹·è´åˆ°åŸæ•°ç»„ä¸­
        for (int k2 = 0; k2 < temp.length; k2++) {
            arr[k2 + left] = temp[k2];
        }
    }



/**
     * å¿«é€Ÿæ’åºï¼Œæ—¶é—´å¤æ‚åº¦O(nlogn),ç©ºé—´å¤æ‚åº¦O(logn)
     * å¿«é€Ÿæ’åºæ˜¯ä¸€ç§ä¸ç¨³å®šçš„æ’åºæ–¹æ³•ã€‚
     * ä¼˜åŒ–ï¼š
     * 1.ä¸‰æ•°å–ä¸­ï¼Œä¼˜åŒ–é€‰å–æ¢è½´
     * 2.ä¼˜åŒ–ä¸å¿…è¦çš„äº¤æ¢
     * 3.å°æ•°ç»„æ—¶ï¼Œé‡‡ç”¨æ’å…¥æ’åº
     * 4.é€’å½’è½¬æˆè¿­ä»£ï¼Œç¼©çŸ­å †æ ˆæ·±åº¦
     * @param array
     */
    public static void quickSort(int[] array){
        qSort(array,0,array.length-1);
    }
    private static void qSort(int[] array,int low,int high){
        //æ¢è½´å€¼
        int pivot;
        //3.å°æ•°ç»„æ—¶é‡‡ç”¨æ’å…¥æ’åº
//        if (low<high){
//            pivot=partition(array,low,high);
//            qSort(array,low,pivot-1);
//            qSort(array,pivot+1,high);
//        }
        if (high-low>MAX_LENGTH_INSER_SORT){
            pivot=partition(array,low,high);
            qSort(array,low,pivot-1);
            qSort(array,pivot+1,high);
        }else
            insertSort(array);
    }
    private static void qSort1(int[] array,int low,int high){
        //æ¢è½´å€¼
        int pivot;
        if (high-low>MAX_LENGTH_INSER_SORT){
            //4.é€’å½’è½¬æ¢æˆè¿­ä»£ï¼Œç¼©å‡å †æ ˆæ·±åº¦
            while (low<high) {
                pivot = partition(array, low, high);
                qSort1(array, low, pivot - 1);
                low=pivot+1;
            }
        }else
            insertSort(array);
    }
    private static int partition(int[] array,int low,int high) {
        //é€‰å–çš„æ¢è½´ï¼Œæ˜¯æ€§èƒ½ç“¶é¢ˆ

        //1.ä¸‰æ•°å–ä¸­ï¼šå°†ä¸‰ä¸ªå…³é”®å­—æ’åºï¼Œå°†ä¸­é—´æ•°ä½œä¸ºæ¢è½´
        int middle=low+(high-low)/2;
        if (array[low]>array[high])
            swap(array,low,high);
        if (array[middle]>array[high])
            swap(array,high,middle);
        if (array[middle]>array[low])
            swap(array,middle,low);
        int pre=array[low];

        //2.ä¼˜åŒ–ä¸å¿…è¦çš„äº¤æ¢
        while (low < high){
            //æ¯”æ¢è½´è®°å½•å°çš„äº¤æ¢åˆ°ä½ç«¯
            while (low < high && array[high] >= pre)
                high--;
//            swap(array, low, high);
            array[low]=array[high];
            //æ¯”æ¢è½´è®°å½•å¤§çš„äº¤æ¢åˆ°é«˜ç«¯
             while (low < high && array[low] <= pre)
                low++;
//            swap(array, low, high);
            array[high]=array[low];
        }
        array[low]=pre;
        return low;
    }

```



é“¾è¡¨ç›¸ä¹˜ï¼Œå°±æ˜¯ä¸ªä½æ•°åœ¨é“¾è¡¨ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œåä½æ•°åœ¨é“¾è¡¨ç¬¬äºŒä¸ªç»“ç‚¹â€¦ä¸¤ä¸ªé“¾è¡¨ç›¸ä¹˜ï¼Œæœ€åè¾“å‡ºä¸€ä¸ªé“¾è¡¨

```java
public class LinkedListMultiplication {

    static class ListNode{
        int val;
        ListNode next;

        public ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }

        public ListNode(int val) {
            this.val = val;
        }
    }

    /**
     * é“¾è¡¨ç›¸ä¹˜ï¼Œå°±æ˜¯ä¸ªä½æ•°åœ¨é“¾è¡¨ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œåä½æ•°åœ¨é“¾è¡¨ç¬¬äºŒä¸ªç»“ç‚¹â€¦ä¸¤ä¸ªé“¾è¡¨ç›¸ä¹˜ï¼Œæœ€åè¾“å‡ºä¸€ä¸ªé“¾è¡¨
     * @param p
     * @param q
     * @return
     */
    public static ListNode multiply(ListNode p, ListNode q){
        if (p == null || q == null){
            return null;
        }

        List<Integer> plist= new ArrayList<>(), qlist = new ArrayList<>();
        int count=0;
        while (p!=null){
            plist.add(p.val);
            p=p.next;
            count++;
        }

        while (q!=null){
            qlist.add(q.val);
            q=q.next;
            count++;
        }

        //ç›¸ä¹˜çš„ç»“æ„æ”¾åˆ°resultç»“æœä¸­
        int[] result = new int[count-1];
        for (int i=0;i<plist.size();i++){
            for (int j=0;j<qlist.size();j++){
                result[i+j]+=plist.get(i)*qlist.get(j);
            }
        }

        for (int i=0; i<count-2; i++){
            result[i+1]+=result[i]/10;
            result[i]=result[i]%10;
        }
        ListNode head= new ListNode(result[0]);
        ListNode curr=head;
        for (int i=1; i<count-2; i++){
            curr.next=new ListNode(result[i]);
            curr=curr.next;
        }

        int last=result[count-2];
        while (last!=0){
            curr.next=new ListNode(last%10);
            curr=curr.next;
            last/=10;
        }

        return head;

    }


    public static void main(String[] args) {
        ListNode p=new ListNode(3);
        p.next=new ListNode(2);
        p.next.next=new ListNode(9);


        ListNode q=new ListNode(9);
        q.next=new ListNode(8);
        q.next.next=new ListNode(7);

        multiply(p,q);

    }
}

```



çº¢é»‘æ ‘ï¼Œå¯èƒ½è¦äº†è§£ä¸‹

<https://zhuanlan.zhihu.com/p/79980618>



```java
1. æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰çº¢è‰²æˆ–é»‘è‰²
2. æ ‘çš„æ ¹å§‹ç»ˆæ˜¯é»‘è‰²çš„ (é»‘åœŸåœ°å­•è‚²é»‘æ ‘æ ¹ï¼ŒğŸ˜„)
3. æ²¡æœ‰ä¸¤ä¸ªç›¸é‚»çš„çº¢è‰²èŠ‚ç‚¹ï¼ˆçº¢è‰²èŠ‚ç‚¹ä¸èƒ½æœ‰çº¢è‰²çˆ¶èŠ‚ç‚¹æˆ–çº¢è‰²å­èŠ‚ç‚¹ï¼Œå¹¶æ²¡æœ‰è¯´ä¸èƒ½å‡ºç°è¿ç»­çš„é»‘è‰²èŠ‚ç‚¹ï¼‰
4. ä»èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬æ ¹ï¼‰åˆ°å…¶ä»»ä½•åä»£NULLèŠ‚ç‚¹(å¶å­ç»“ç‚¹ä¸‹æ–¹æŒ‚çš„ä¸¤ä¸ªç©ºèŠ‚ç‚¹ï¼Œå¹¶ä¸”è®¤ä¸ºä»–ä»¬æ˜¯é»‘è‰²çš„)çš„æ¯æ¡è·¯å¾„éƒ½å…·æœ‰ç›¸åŒæ•°é‡çš„é»‘è‰²èŠ‚ç‚¹



çº¢é»‘æ ‘æœ‰ä¸¤å¤§æ“ä½œ:

1. recolor (é‡æ–°æ ‡è®°é»‘è‰²æˆ–çº¢è‰²)
2. rotation (æ—‹è½¬ï¼Œè¿™æ˜¯æ ‘è¾¾åˆ°å¹³è¡¡çš„å…³é”®)

  
  public class RBTree<T extends Comparable<T>> {

    private RBTNode<T> mRoot;    // æ ¹ç»“ç‚¹

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode<T extends Comparable<T>> {
        boolean color;        // é¢œè‰²
        T key;                // å…³é”®å­—(é”®å€¼)
        RBTNode<T> left;    // å·¦å­©å­
        RBTNode<T> right;    // å³å­©å­
        RBTNode<T> parent;    // çˆ¶ç»“ç‚¹

        public RBTNode(T key, boolean color, RBTNode<T> parent, RBTNode<T> left, RBTNode<T> right) {
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

        public T getKey() {
            return key;
        }

        public String toString() {
            return ""+key+(this.color==RED?"(R)":"B");
        }
    }

    public RBTree() {
        mRoot=null;
    }

    private RBTNode<T> parentOf(RBTNode<T> node) {
        return node!=null ? node.parent : null;
    }
    private boolean colorOf(RBTNode<T> node) {
        return node!=null ? node.color : BLACK;
    }
    private boolean isRed(RBTNode<T> node) {
        return ((node!=null)&&(node.color==RED)) ? true : false;
    }
    private boolean isBlack(RBTNode<T> node) {
        return !isRed(node);
    }
    private void setBlack(RBTNode<T> node) {
        if (node!=null)
            node.color = BLACK;
    }
    private void setRed(RBTNode<T> node) {
        if (node!=null)
            node.color = RED;
    }
    private void setParent(RBTNode<T> node, RBTNode<T> parent) {
        if (node!=null)
            node.parent = parent;
    }
    private void setColor(RBTNode<T> node, boolean color) {
        if (node!=null)
            node.color = color;
    }

    /*
     * å‰åºéå†"çº¢é»‘æ ‘"
     */
    private void preOrder(RBTNode<T> tree) {
        if(tree != null) {
            System.out.print(tree.key+" ");
            preOrder(tree.left);
            preOrder(tree.right);
        }
    }

    public void preOrder() {
        preOrder(mRoot);
    }

    /*
     * ä¸­åºéå†"çº¢é»‘æ ‘"
     */
    private void inOrder(RBTNode<T> tree) {
        if(tree != null) {
            inOrder(tree.left);
            System.out.print(tree.key+" ");
            inOrder(tree.right);
        }
    }

    public void inOrder() {
        inOrder(mRoot);
    }


    /*
     * ååºéå†"çº¢é»‘æ ‘"
     */
    private void postOrder(RBTNode<T> tree) {
        if(tree != null)
        {
            postOrder(tree.left);
            postOrder(tree.right);
            System.out.print(tree.key+" ");
        }
    }

    public void postOrder() {
        postOrder(mRoot);
    }


    /*
     * (é€’å½’å®ç°)æŸ¥æ‰¾"çº¢é»‘æ ‘x"ä¸­é”®å€¼ä¸ºkeyçš„èŠ‚ç‚¹
     */
    private RBTNode<T> search(RBTNode<T> x, T key) {
        if (x==null)
            return x;

        int cmp = key.compareTo(x.key);
        if (cmp < 0)
            return search(x.left, key);
        else if (cmp > 0)
            return search(x.right, key);
        else
            return x;
    }

    public RBTNode<T> search(T key) {
        return search(mRoot, key);
    }

    /*
     * (éé€’å½’å®ç°)æŸ¥æ‰¾"çº¢é»‘æ ‘x"ä¸­é”®å€¼ä¸ºkeyçš„èŠ‚ç‚¹
     */
    private RBTNode<T> iterativeSearch(RBTNode<T> x, T key) {
        while (x!=null) {
            int cmp = key.compareTo(x.key);

            if (cmp < 0)
                x = x.left;
            else if (cmp > 0)
                x = x.right;
            else
                return x;
        }

        return x;
    }

    public RBTNode<T> iterativeSearch(T key) {
        return iterativeSearch(mRoot, key);
    }

    /*
     * æŸ¥æ‰¾æœ€å°ç»“ç‚¹ï¼šè¿”å›treeä¸ºæ ¹ç»“ç‚¹çš„çº¢é»‘æ ‘çš„æœ€å°ç»“ç‚¹ã€‚
     */
    private RBTNode<T> minimum(RBTNode<T> tree) {
        if (tree == null)
            return null;

        while(tree.left != null)
            tree = tree.left;
        return tree;
    }

    public T minimum() {
        RBTNode<T> p = minimum(mRoot);
        if (p != null)
            return p.key;

        return null;
    }

    /*
     * æŸ¥æ‰¾æœ€å¤§ç»“ç‚¹ï¼šè¿”å›treeä¸ºæ ¹ç»“ç‚¹çš„çº¢é»‘æ ‘çš„æœ€å¤§ç»“ç‚¹ã€‚
     */
    private RBTNode<T> maximum(RBTNode<T> tree) {
        if (tree == null)
            return null;

        while(tree.right != null)
            tree = tree.right;
        return tree;
    }

    public T maximum() {
        RBTNode<T> p = maximum(mRoot);
        if (p != null)
            return p.key;

        return null;
    }

    /*
     * æ‰¾ç»“ç‚¹(x)çš„åç»§ç»“ç‚¹ã€‚å³ï¼ŒæŸ¥æ‰¾"çº¢é»‘æ ‘ä¸­æ•°æ®å€¼å¤§äºè¯¥ç»“ç‚¹"çš„"æœ€å°ç»“ç‚¹"ã€‚
     */
    public RBTNode<T> successor(RBTNode<T> x) {
        // å¦‚æœxå­˜åœ¨å³å­©å­ï¼Œåˆ™"xçš„åç»§ç»“ç‚¹"ä¸º "ä»¥å…¶å³å­©å­ä¸ºæ ¹çš„å­æ ‘çš„æœ€å°ç»“ç‚¹"ã€‚
        if (x.right != null)
            return minimum(x.right);

        // å¦‚æœxæ²¡æœ‰å³å­©å­ã€‚åˆ™xæœ‰ä»¥ä¸‹ä¸¤ç§å¯èƒ½ï¼š
        // (01) xæ˜¯"ä¸€ä¸ªå·¦å­©å­"ï¼Œåˆ™"xçš„åç»§ç»“ç‚¹"ä¸º "å®ƒçš„çˆ¶ç»“ç‚¹"ã€‚
        // (02) xæ˜¯"ä¸€ä¸ªå³å­©å­"ï¼Œåˆ™æŸ¥æ‰¾"xçš„æœ€ä½çš„çˆ¶ç»“ç‚¹ï¼Œå¹¶ä¸”è¯¥çˆ¶ç»“ç‚¹è¦å…·æœ‰å·¦å­©å­"ï¼Œæ‰¾åˆ°çš„è¿™ä¸ª"æœ€ä½çš„çˆ¶ç»“ç‚¹"å°±æ˜¯"xçš„åç»§ç»“ç‚¹"ã€‚
        RBTNode<T> y = x.parent;
        while ((y!=null) && (x==y.right)) {
            x = y;
            y = y.parent;
        }

        return y;
    }

    /*
     * æ‰¾ç»“ç‚¹(x)çš„å‰é©±ç»“ç‚¹ã€‚å³ï¼ŒæŸ¥æ‰¾"çº¢é»‘æ ‘ä¸­æ•°æ®å€¼å°äºè¯¥ç»“ç‚¹"çš„"æœ€å¤§ç»“ç‚¹"ã€‚
     */
    public RBTNode<T> predecessor(RBTNode<T> x) {
        // å¦‚æœxå­˜åœ¨å·¦å­©å­ï¼Œåˆ™"xçš„å‰é©±ç»“ç‚¹"ä¸º "ä»¥å…¶å·¦å­©å­ä¸ºæ ¹çš„å­æ ‘çš„æœ€å¤§ç»“ç‚¹"ã€‚
        if (x.left != null)
            return maximum(x.left);

        // å¦‚æœxæ²¡æœ‰å·¦å­©å­ã€‚åˆ™xæœ‰ä»¥ä¸‹ä¸¤ç§å¯èƒ½ï¼š
        // (01) xæ˜¯"ä¸€ä¸ªå³å­©å­"ï¼Œåˆ™"xçš„å‰é©±ç»“ç‚¹"ä¸º "å®ƒçš„çˆ¶ç»“ç‚¹"ã€‚
        // (01) xæ˜¯"ä¸€ä¸ªå·¦å­©å­"ï¼Œåˆ™æŸ¥æ‰¾"xçš„æœ€ä½çš„çˆ¶ç»“ç‚¹ï¼Œå¹¶ä¸”è¯¥çˆ¶ç»“ç‚¹è¦å…·æœ‰å³å­©å­"ï¼Œæ‰¾åˆ°çš„è¿™ä¸ª"æœ€ä½çš„çˆ¶ç»“ç‚¹"å°±æ˜¯"xçš„å‰é©±ç»“ç‚¹"ã€‚
        RBTNode<T> y = x.parent;
        while ((y!=null) && (x==y.left)) {
            x = y;
            y = y.parent;
        }

        return y;
    }

    /*
     * å¯¹çº¢é»‘æ ‘çš„èŠ‚ç‚¹(x)è¿›è¡Œå·¦æ—‹è½¬
     *
     * å·¦æ—‹ç¤ºæ„å›¾(å¯¹èŠ‚ç‚¹xè¿›è¡Œå·¦æ—‹)ï¼š
     *      px                              px
     *     /                               /
     *    x                               y
     *   /  \      --(å·¦æ—‹)-.           / \                #
     *  lx   y                          x  ry
     *     /   \                       /  \
     *    ly   ry                     lx  ly
     *
     *
     */
    private void leftRotate(RBTNode<T> x) {
        // è®¾ç½®xçš„å³å­©å­ä¸ºy
        RBTNode<T> y = x.right;

        // å°† â€œyçš„å·¦å­©å­â€ è®¾ä¸º â€œxçš„å³å­©å­â€ï¼›
        // å¦‚æœyçš„å·¦å­©å­éç©ºï¼Œå°† â€œxâ€ è®¾ä¸º â€œyçš„å·¦å­©å­çš„çˆ¶äº²â€
        x.right = y.left;
        if (y.left != null)
            y.left.parent = x;

        // å°† â€œxçš„çˆ¶äº²â€ è®¾ä¸º â€œyçš„çˆ¶äº²â€
        y.parent = x.parent;

        if (x.parent == null) {
            this.mRoot = y;            // å¦‚æœ â€œxçš„çˆ¶äº²â€ æ˜¯ç©ºèŠ‚ç‚¹ï¼Œåˆ™å°†yè®¾ä¸ºæ ¹èŠ‚ç‚¹
        } else {
            if (x.parent.left == x)
                x.parent.left = y;    // å¦‚æœ xæ˜¯å®ƒçˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ï¼Œåˆ™å°†yè®¾ä¸ºâ€œxçš„çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­â€
            else
                x.parent.right = y;    // å¦‚æœ xæ˜¯å®ƒçˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ï¼Œåˆ™å°†yè®¾ä¸ºâ€œxçš„çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­â€
        }

        // å°† â€œxâ€ è®¾ä¸º â€œyçš„å·¦å­©å­â€
        y.left = x;
        // å°† â€œxçš„çˆ¶èŠ‚ç‚¹â€ è®¾ä¸º â€œyâ€
        x.parent = y;
    }

    /*
     * å¯¹çº¢é»‘æ ‘çš„èŠ‚ç‚¹(y)è¿›è¡Œå³æ—‹è½¬
     *
     * å³æ—‹ç¤ºæ„å›¾(å¯¹èŠ‚ç‚¹yè¿›è¡Œå·¦æ—‹)ï¼š
     *            py                               py
     *           /                                /
     *          y                                x
     *         /  \      --(å³æ—‹)-.            /  \                     #
     *        x   ry                           lx   y
     *       / \                                   / \                   #
     *      lx  rx                                rx  ry
     *
     */
    private void rightRotate(RBTNode<T> y) {
        // è®¾ç½®xæ˜¯å½“å‰èŠ‚ç‚¹çš„å·¦å­©å­ã€‚
        RBTNode<T> x = y.left;

        // å°† â€œxçš„å³å­©å­â€ è®¾ä¸º â€œyçš„å·¦å­©å­â€ï¼›
        // å¦‚æœ"xçš„å³å­©å­"ä¸ä¸ºç©ºçš„è¯ï¼Œå°† â€œyâ€ è®¾ä¸º â€œxçš„å³å­©å­çš„çˆ¶äº²â€
        y.left = x.right;
        if (x.right != null)
            x.right.parent = y;

        // å°† â€œyçš„çˆ¶äº²â€ è®¾ä¸º â€œxçš„çˆ¶äº²â€
        x.parent = y.parent;

        if (y.parent == null) {
            this.mRoot = x;            // å¦‚æœ â€œyçš„çˆ¶äº²â€ æ˜¯ç©ºèŠ‚ç‚¹ï¼Œåˆ™å°†xè®¾ä¸ºæ ¹èŠ‚ç‚¹
        } else {
            if (y == y.parent.right)
                y.parent.right = x;    // å¦‚æœ yæ˜¯å®ƒçˆ¶èŠ‚ç‚¹çš„å³å­©å­ï¼Œåˆ™å°†xè®¾ä¸ºâ€œyçš„çˆ¶èŠ‚ç‚¹çš„å³å­©å­â€
            else
                y.parent.left = x;    // (yæ˜¯å®ƒçˆ¶èŠ‚ç‚¹çš„å·¦å­©å­) å°†xè®¾ä¸ºâ€œxçš„çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­â€
        }

        // å°† â€œyâ€ è®¾ä¸º â€œxçš„å³å­©å­â€
        x.right = y;

        // å°† â€œyçš„çˆ¶èŠ‚ç‚¹â€ è®¾ä¸º â€œxâ€
        y.parent = x;
    }

    /*
     * çº¢é»‘æ ‘æ’å…¥ä¿®æ­£å‡½æ•°
     *
     * åœ¨å‘çº¢é»‘æ ‘ä¸­æ’å…¥èŠ‚ç‚¹ä¹‹å(å¤±å»å¹³è¡¡)ï¼Œå†è°ƒç”¨è¯¥å‡½æ•°ï¼›
     * ç›®çš„æ˜¯å°†å®ƒé‡æ–°å¡‘é€ æˆä¸€é¢—çº¢é»‘æ ‘ã€‚
     *
     * å‚æ•°è¯´æ˜ï¼š
     *     node æ’å…¥çš„ç»“ç‚¹        // å¯¹åº”ã€Šç®—æ³•å¯¼è®ºã€‹ä¸­çš„z
     */
    private void insertFixUp(RBTNode<T> node) {
        RBTNode<T> parent, gparent;

        // è‹¥â€œçˆ¶èŠ‚ç‚¹å­˜åœ¨ï¼Œå¹¶ä¸”çˆ¶èŠ‚ç‚¹çš„é¢œè‰²æ˜¯çº¢è‰²â€
        while (((parent = parentOf(node))!=null) && isRed(parent)) {
            gparent = parentOf(parent);

            //è‹¥â€œçˆ¶èŠ‚ç‚¹â€æ˜¯â€œç¥–çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­â€
            if (parent == gparent.left) {
                // Case 1æ¡ä»¶ï¼šå”å”èŠ‚ç‚¹æ˜¯çº¢è‰²
                RBTNode<T> uncle = gparent.right;
                if ((uncle!=null) && isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                }

                // Case 2æ¡ä»¶ï¼šå”å”æ˜¯é»‘è‰²ï¼Œä¸”å½“å‰èŠ‚ç‚¹æ˜¯å³å­©å­
                if (parent.right == node) {
                    RBTNode<T> tmp;
                    leftRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }

                // Case 3æ¡ä»¶ï¼šå”å”æ˜¯é»‘è‰²ï¼Œä¸”å½“å‰èŠ‚ç‚¹æ˜¯å·¦å­©å­ã€‚
                setBlack(parent);
                setRed(gparent);
                rightRotate(gparent);
            } else {    //è‹¥â€œzçš„çˆ¶èŠ‚ç‚¹â€æ˜¯â€œzçš„ç¥–çˆ¶èŠ‚ç‚¹çš„å³å­©å­â€
                // Case 1æ¡ä»¶ï¼šå”å”èŠ‚ç‚¹æ˜¯çº¢è‰²
                RBTNode<T> uncle = gparent.left;
                if ((uncle!=null) && isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                }

                // Case 2æ¡ä»¶ï¼šå”å”æ˜¯é»‘è‰²ï¼Œä¸”å½“å‰èŠ‚ç‚¹æ˜¯å·¦å­©å­
                if (parent.left == node) {
                    RBTNode<T> tmp;
                    rightRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }

                // Case 3æ¡ä»¶ï¼šå”å”æ˜¯é»‘è‰²ï¼Œä¸”å½“å‰èŠ‚ç‚¹æ˜¯å³å­©å­ã€‚
                setBlack(parent);
                setRed(gparent);
                leftRotate(gparent);
            }
        }

        // å°†æ ¹èŠ‚ç‚¹è®¾ä¸ºé»‘è‰²
        setBlack(this.mRoot);
    }

    /*
     * å°†ç»“ç‚¹æ’å…¥åˆ°çº¢é»‘æ ‘ä¸­
     *
     * å‚æ•°è¯´æ˜ï¼š
     *     node æ’å…¥çš„ç»“ç‚¹        // å¯¹åº”ã€Šç®—æ³•å¯¼è®ºã€‹ä¸­çš„node
     */
    private void insert(RBTNode<T> node) {
        int cmp;
        RBTNode<T> y = null;
        RBTNode<T> x = this.mRoot;

        // 1. å°†çº¢é»‘æ ‘å½“ä½œä¸€é¢—äºŒå‰æŸ¥æ‰¾æ ‘ï¼Œå°†èŠ‚ç‚¹æ·»åŠ åˆ°äºŒå‰æŸ¥æ‰¾æ ‘ä¸­ã€‚
        while (x != null) {
            y = x;
            cmp = node.key.compareTo(x.key);
            if (cmp < 0)
                x = x.left;
            else
                x = x.right;
        }

        node.parent = y;
        if (y!=null) {
            cmp = node.key.compareTo(y.key);
            if (cmp < 0)
                y.left = node;
            else
                y.right = node;
        } else {
            this.mRoot = node;
        }

        // 2. è®¾ç½®èŠ‚ç‚¹çš„é¢œè‰²ä¸ºçº¢è‰²
        node.color = RED;

        // 3. å°†å®ƒé‡æ–°ä¿®æ­£ä¸ºä¸€é¢—äºŒå‰æŸ¥æ‰¾æ ‘
        insertFixUp(node);
    }

    /*
     * æ–°å»ºç»“ç‚¹(key)ï¼Œå¹¶å°†å…¶æ’å…¥åˆ°çº¢é»‘æ ‘ä¸­
     *
     * å‚æ•°è¯´æ˜ï¼š
     *     key æ’å…¥ç»“ç‚¹çš„é”®å€¼
     */
    public void insert(T key) {
        RBTNode<T> node=new RBTNode<T>(key,BLACK,null,null,null);

        // å¦‚æœæ–°å»ºç»“ç‚¹å¤±è´¥ï¼Œåˆ™è¿”å›ã€‚
        if (node != null)
            insert(node);
    }


    /*
     * çº¢é»‘æ ‘åˆ é™¤ä¿®æ­£å‡½æ•°
     *
     * åœ¨ä»çº¢é»‘æ ‘ä¸­åˆ é™¤æ’å…¥èŠ‚ç‚¹ä¹‹å(çº¢é»‘æ ‘å¤±å»å¹³è¡¡)ï¼Œå†è°ƒç”¨è¯¥å‡½æ•°ï¼›
     * ç›®çš„æ˜¯å°†å®ƒé‡æ–°å¡‘é€ æˆä¸€é¢—çº¢é»‘æ ‘ã€‚
     *
     * å‚æ•°è¯´æ˜ï¼š
     *     node å¾…ä¿®æ­£çš„èŠ‚ç‚¹
     */
    private void removeFixUp(RBTNode<T> node, RBTNode<T> parent) {
        RBTNode<T> other;

        while ((node==null || isBlack(node)) && (node != this.mRoot)) {
            if (parent.left == node) {
                other = parent.right;
                if (isRed(other)) {
                    // Case 1: xçš„å…„å¼Ÿwæ˜¯çº¢è‰²çš„
                    setBlack(other);
                    setRed(parent);
                    leftRotate(parent);
                    other = parent.right;
                }

                if ((other.left==null || isBlack(other.left)) &&
                        (other.right==null || isBlack(other.right))) {
                    // Case 2: xçš„å…„å¼Ÿwæ˜¯é»‘è‰²ï¼Œä¸”wçš„ä¿©ä¸ªå­©å­ä¹Ÿéƒ½æ˜¯é»‘è‰²çš„
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                } else {

                    if (other.right==null || isBlack(other.right)) {
                        // Case 3: xçš„å…„å¼Ÿwæ˜¯é»‘è‰²çš„ï¼Œå¹¶ä¸”wçš„å·¦å­©å­æ˜¯çº¢è‰²ï¼Œå³å­©å­ä¸ºé»‘è‰²ã€‚
                        setBlack(other.left);
                        setRed(other);
                        rightRotate(other);
                        other = parent.right;
                    }
                    // Case 4: xçš„å…„å¼Ÿwæ˜¯é»‘è‰²çš„ï¼›å¹¶ä¸”wçš„å³å­©å­æ˜¯çº¢è‰²çš„ï¼Œå·¦å­©å­ä»»æ„é¢œè‰²ã€‚
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.right);
                    leftRotate(parent);
                    node = this.mRoot;
                    break;
                }
            } else {

                other = parent.left;
                if (isRed(other)) {
                    // Case 1: xçš„å…„å¼Ÿwæ˜¯çº¢è‰²çš„
                    setBlack(other);
                    setRed(parent);
                    rightRotate(parent);
                    other = parent.left;
                }

                if ((other.left==null || isBlack(other.left)) &&
                        (other.right==null || isBlack(other.right))) {
                    // Case 2: xçš„å…„å¼Ÿwæ˜¯é»‘è‰²ï¼Œä¸”wçš„ä¿©ä¸ªå­©å­ä¹Ÿéƒ½æ˜¯é»‘è‰²çš„
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                } else {

                    if (other.left==null || isBlack(other.left)) {
                        // Case 3: xçš„å…„å¼Ÿwæ˜¯é»‘è‰²çš„ï¼Œå¹¶ä¸”wçš„å·¦å­©å­æ˜¯çº¢è‰²ï¼Œå³å­©å­ä¸ºé»‘è‰²ã€‚
                        setBlack(other.right);
                        setRed(other);
                        leftRotate(other);
                        other = parent.left;
                    }

                    // Case 4: xçš„å…„å¼Ÿwæ˜¯é»‘è‰²çš„ï¼›å¹¶ä¸”wçš„å³å­©å­æ˜¯çº¢è‰²çš„ï¼Œå·¦å­©å­ä»»æ„é¢œè‰²ã€‚
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.left);
                    rightRotate(parent);
                    node = this.mRoot;
                    break;
                }
            }
        }

        if (node!=null)
            setBlack(node);
    }

    /*
     * åˆ é™¤ç»“ç‚¹(node)ï¼Œå¹¶è¿”å›è¢«åˆ é™¤çš„ç»“ç‚¹
     *
     * å‚æ•°è¯´æ˜ï¼š
     *     node åˆ é™¤çš„ç»“ç‚¹
     */
    private void remove(RBTNode<T> node) {
        RBTNode<T> child, parent;
        boolean color;

        // è¢«åˆ é™¤èŠ‚ç‚¹çš„"å·¦å³å­©å­éƒ½ä¸ä¸ºç©º"çš„æƒ…å†µã€‚
        if ( (node.left!=null) && (node.right!=null) ) {
            // è¢«åˆ èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹ã€‚(ç§°ä¸º"å–ä»£èŠ‚ç‚¹")
            // ç”¨å®ƒæ¥å–ä»£"è¢«åˆ èŠ‚ç‚¹"çš„ä½ç½®ï¼Œç„¶åå†å°†"è¢«åˆ èŠ‚ç‚¹"å»æ‰ã€‚
            RBTNode<T> replace = node;

            // è·å–åç»§èŠ‚ç‚¹
            replace = replace.right;
            while (replace.left != null)
                replace = replace.left;

            // "nodeèŠ‚ç‚¹"ä¸æ˜¯æ ¹èŠ‚ç‚¹(åªæœ‰æ ¹èŠ‚ç‚¹ä¸å­˜åœ¨çˆ¶èŠ‚ç‚¹)
            if (parentOf(node)!=null) {
                if (parentOf(node).left == node)
                    parentOf(node).left = replace;
                else
                    parentOf(node).right = replace;
            } else {
                // "nodeèŠ‚ç‚¹"æ˜¯æ ¹èŠ‚ç‚¹ï¼Œæ›´æ–°æ ¹èŠ‚ç‚¹ã€‚
                this.mRoot = replace;
            }

            // childæ˜¯"å–ä»£èŠ‚ç‚¹"çš„å³å­©å­ï¼Œä¹Ÿæ˜¯éœ€è¦"è°ƒæ•´çš„èŠ‚ç‚¹"ã€‚
            // "å–ä»£èŠ‚ç‚¹"è‚¯å®šä¸å­˜åœ¨å·¦å­©å­ï¼å› ä¸ºå®ƒæ˜¯ä¸€ä¸ªåç»§èŠ‚ç‚¹ã€‚
            child = replace.right;
            parent = parentOf(replace);
            // ä¿å­˜"å–ä»£èŠ‚ç‚¹"çš„é¢œè‰²
            color = colorOf(replace);

            // "è¢«åˆ é™¤èŠ‚ç‚¹"æ˜¯"å®ƒçš„åç»§èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹"
            if (parent == node) {
                parent = replace;
            } else {
                // childä¸ä¸ºç©º
                if (child!=null)
                    setParent(child, parent);
                parent.left = child;

                replace.right = node.right;
                setParent(node.right, replace);
            }

            replace.parent = node.parent;
            replace.color = node.color;
            replace.left = node.left;
            node.left.parent = replace;

            if (color == BLACK)
                removeFixUp(child, parent);

            node = null;
            return ;
        }

        if (node.left !=null) {
            child = node.left;
        } else {
            child = node.right;
        }

        parent = node.parent;
        // ä¿å­˜"å–ä»£èŠ‚ç‚¹"çš„é¢œè‰²
        color = node.color;

        if (child!=null)
            child.parent = parent;

        // "nodeèŠ‚ç‚¹"ä¸æ˜¯æ ¹èŠ‚ç‚¹
        if (parent!=null) {
            if (parent.left == node)
                parent.left = child;
            else
                parent.right = child;
        } else {
            this.mRoot = child;
        }

        if (color == BLACK)
            removeFixUp(child, parent);
        node = null;
    }

    /*
     * åˆ é™¤ç»“ç‚¹(z)ï¼Œå¹¶è¿”å›è¢«åˆ é™¤çš„ç»“ç‚¹
     *
     * å‚æ•°è¯´æ˜ï¼š
     *     tree çº¢é»‘æ ‘çš„æ ¹ç»“ç‚¹
     *     z åˆ é™¤çš„ç»“ç‚¹
     */
    public void remove(T key) {
        RBTNode<T> node;

        if ((node = search(mRoot, key)) != null)
            remove(node);
    }

    /*
     * é”€æ¯çº¢é»‘æ ‘
     */
    private void destroy(RBTNode<T> tree) {
        if (tree==null)
            return ;

        if (tree.left != null)
            destroy(tree.left);
        if (tree.right != null)
            destroy(tree.right);

        tree=null;
    }

    public void clear() {
        destroy(mRoot);
        mRoot = null;
    }

    /*
     * æ‰“å°"çº¢é»‘æ ‘"
     *
     * key        -- èŠ‚ç‚¹çš„é”®å€¼
     * direction  --  0ï¼Œè¡¨ç¤ºè¯¥èŠ‚ç‚¹æ˜¯æ ¹èŠ‚ç‚¹;
     *               -1ï¼Œè¡¨ç¤ºè¯¥èŠ‚ç‚¹æ˜¯å®ƒçš„çˆ¶ç»“ç‚¹çš„å·¦å­©å­;
     *                1ï¼Œè¡¨ç¤ºè¯¥èŠ‚ç‚¹æ˜¯å®ƒçš„çˆ¶ç»“ç‚¹çš„å³å­©å­ã€‚
     */
    private void print(RBTNode<T> tree, T key, int direction) {

        if(tree != null) {

            if(direction==0)    // treeæ˜¯æ ¹èŠ‚ç‚¹
                System.out.printf("%2d(B) is root\n", tree.key);
            else                // treeæ˜¯åˆ†æ”¯èŠ‚ç‚¹
                System.out.printf("%2d(%s) is %2d's %6s child\n", tree.key, isRed(tree)?"R":"B", key, direction==1?"right" : "left");

            print(tree.left, tree.key, -1);
            print(tree.right,tree.key,  1);
        }
    }

    public void print() {
        if (mRoot != null)
            print(mRoot, mRoot.key, 0);
    }


```





0/1èƒŒåŒ…ç®—æ³•æ€è·¯è¯´ä¸€ä¸‹



01èƒŒåŒ…é—®é¢˜

æœ‰Nä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ã€‚ç¬¬iä»¶ç‰©å“çš„è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„è´¹ç”¨æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚



ç”¨å­é—®é¢˜å®šä¹‰çŠ¶æ€ï¼šå³f[i][v]è¡¨ç¤ºå‰iä»¶ç‰©å“æ°æ”¾å…¥ä¸€ä¸ªå®¹é‡ä¸ºvçš„èƒŒåŒ…å¯ä»¥è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚åˆ™å…¶çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¾¿æ˜¯ï¼šf[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}ã€‚

æ³¨æ„f[i][v]æœ‰æ„ä¹‰å½“ä¸”ä»…å½“å­˜åœ¨ä¸€ä¸ªå‰iä»¶ç‰©å“çš„å­é›†ï¼Œå…¶è´¹ç”¨æ€»å’Œä¸ºvã€‚æ‰€ä»¥æŒ‰ç…§è¿™ä¸ªæ–¹ç¨‹é€’æ¨å®Œæ¯•åï¼Œæœ€ç»ˆçš„ç­”æ¡ˆå¹¶ä¸ä¸€å®šæ˜¯f[N][V]ï¼Œè€Œæ˜¯f[N][0..V]çš„æœ€å¤§å€¼ã€‚å¦‚æœå°†çŠ¶æ€çš„å®šä¹‰ä¸­çš„â€œæ°â€å­—å»æ‰ï¼Œåœ¨è½¬ç§»æ–¹ç¨‹ä¸­å°±è¦å†åŠ å…¥ä¸€é¡¹f[i][v-1]ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯f[N][V]å°±æ˜¯æœ€åçš„ç­”æ¡ˆã€‚è‡³äºä¸ºä»€ä¹ˆè¿™æ ·å°±å¯ä»¥ï¼Œç”±ä½ è‡ªå·±æ¥ä½“ä¼šäº†ã€‚

ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦

for i=1..N
for v=V..0
f[v]=max{f[v],f[v-c[i]]+w[i]};



å®Œå…¨èƒŒåŒ…é—®é¢˜

æœ‰Nç§ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ï¼Œæ¯ç§ç‰©å“éƒ½æœ‰æ— é™ä»¶å¯ç”¨ã€‚ç¬¬iç§ç‰©å“çš„è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„è´¹ç”¨æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚



è¿™ä¸ªé—®é¢˜éå¸¸ç±»ä¼¼äº01èƒŒåŒ…é—®é¢˜ï¼Œæ‰€ä¸åŒçš„æ˜¯æ¯ç§ç‰©å“æœ‰æ— é™ä»¶ã€‚ä¹Ÿå°±æ˜¯ä»æ¯ç§ç‰©å“çš„è§’åº¦è€ƒè™‘ï¼Œä¸å®ƒç›¸å…³çš„ç­–ç•¥å·²å¹¶éå–æˆ–ä¸å–ä¸¤ç§ï¼Œè€Œæ˜¯æœ‰å–0ä»¶ã€å–1ä»¶ã€å–2ä»¶â€¦â€¦ç­‰å¾ˆå¤šç§ã€‚å¦‚æœä»ç„¶æŒ‰ç…§è§£01èƒŒåŒ…æ—¶çš„æ€è·¯ï¼Œä»¤f[i][v]è¡¨ç¤ºå‰iç§ç‰©å“æ°æ”¾å…¥ä¸€ä¸ªå®¹é‡ä¸ºvçš„èƒŒåŒ…çš„æœ€å¤§æƒå€¼ã€‚ä»ç„¶å¯ä»¥æŒ‰ç…§æ¯ç§ç‰©å“ä¸åŒçš„ç­–ç•¥å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œåƒè¿™æ ·ï¼šf[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<= v}ã€‚è¿™è·Ÿ01èƒŒåŒ…é—®é¢˜ä¸€æ ·æœ‰O(N*V)ä¸ªçŠ¶æ€éœ€è¦æ±‚è§£ï¼Œä½†æ±‚è§£æ¯ä¸ªçŠ¶æ€çš„æ—¶é—´åˆ™ä¸æ˜¯å¸¸æ•°äº†ï¼Œæ±‚è§£çŠ¶æ€f[i][v]çš„æ—¶é—´æ˜¯O(v/c[i])ï¼Œæ€»çš„å¤æ‚åº¦æ˜¯è¶…è¿‡O(VN)çš„ã€‚

æ›´é«˜æ•ˆçš„è½¬åŒ–æ–¹æ³•æ˜¯ï¼šæŠŠç¬¬iç§ç‰©å“æ‹†æˆè´¹ç”¨ä¸ºc[i]*2^kã€ä»·å€¼ä¸ºw[i]*2^kçš„è‹¥å¹²ä»¶ç‰©å“ï¼Œå…¶ä¸­kæ»¡è¶³c[i]*2^k<Vã€‚è¿™æ˜¯äºŒè¿›åˆ¶çš„æ€æƒ³ï¼Œå› ä¸ºä¸ç®¡æœ€ä¼˜ç­–ç•¥é€‰å‡ ä»¶ç¬¬iç§ç‰©å“ï¼Œæ€»å¯ä»¥è¡¨ç¤ºæˆè‹¥å¹²ä¸ª2^kä»¶ç‰©å“çš„å’Œã€‚



å¤šé‡èƒŒåŒ…é—®é¢˜

æœ‰Nç§ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ã€‚ç¬¬iç§ç‰©å“æœ€å¤šæœ‰n[i]ä»¶å¯ç”¨ï¼Œæ¯ä»¶è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„è´¹ç”¨æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚



åŸºæœ¬ç®—æ³•
è¿™é¢˜ç›®å’Œå®Œå…¨èƒŒåŒ…é—®é¢˜å¾ˆç±»ä¼¼ã€‚åŸºæœ¬çš„æ–¹ç¨‹åªéœ€å°†å®Œå…¨èƒŒåŒ…é—®é¢˜çš„æ–¹ç¨‹ç•¥å¾®ä¸€æ”¹å³å¯ï¼Œå› ä¸ºå¯¹äºç¬¬iç§ç‰©å“æœ‰n[i]+1ç§ç­–ç•¥ï¼šå–0ä»¶ï¼Œå–1ä»¶â€¦â€¦å– n[i]ä»¶ã€‚ä»¤f[i][v]è¡¨ç¤ºå‰iç§ç‰©å“æ°æ”¾å…¥ä¸€ä¸ªå®¹é‡ä¸ºvçš„èƒŒåŒ…çš„æœ€å¤§æƒå€¼ï¼Œåˆ™ï¼šf[i][v]=max{f[i-1][v-k*c[i]]+ k*w[i]|0<=k<=n[i]}ã€‚å¤æ‚åº¦æ˜¯O(V*âˆ‘n[i])ã€‚

å¯ç”¨é€šè¿‡è½¬åŒ–æˆ01èƒŒåŒ…é™ä½å¤æ‚åº¦ï¼š

æ–¹æ³•æ˜¯ï¼šå°†ç¬¬iç§ç‰©å“åˆ†æˆè‹¥å¹²ä»¶ç‰©å“ï¼Œå…¶ä¸­æ¯ä»¶ç‰©å“æœ‰ä¸€ä¸ªç³»æ•°ï¼Œè¿™ä»¶ç‰©å“çš„è´¹ç”¨å’Œä»·å€¼å‡æ˜¯åŸæ¥çš„è´¹ç”¨å’Œä»·å€¼ä¹˜ä»¥è¿™ä¸ªç³»æ•°ã€‚ä½¿è¿™äº›ç³»æ•°åˆ†åˆ«ä¸º 1,2,4,...,2^(k-1),n[i]-2^k+1ï¼Œä¸”kæ˜¯æ»¡è¶³n[i]-2^k+1>0çš„æœ€å¤§æ•´æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœn[i]ä¸º13ï¼Œå°±å°†è¿™ç§ç‰©å“åˆ†æˆç³»æ•°åˆ†åˆ«ä¸º1,2,4,6çš„å››ä»¶ç‰©å“ã€‚

ç®—æ³•çš„å¤æ‚åº¦ç”±O(V*âˆ‘n[i])æ”¹è¿›åˆ°O(V*âˆ‘log n[i])ã€‚



æ··åˆä¸‰ç§èƒŒåŒ…é—®é¢˜
é—®é¢˜
å¦‚æœå°†P01ã€P02ã€P03æ··åˆèµ·æ¥ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ‰çš„ç‰©å“åªå¯ä»¥å–ä¸€æ¬¡ï¼ˆ01èƒŒåŒ…ï¼‰ï¼Œæœ‰çš„ç‰©å“å¯ä»¥å–æ— é™æ¬¡ï¼ˆå®Œå…¨èƒŒåŒ…ï¼‰ï¼Œæœ‰çš„ç‰©å“å¯ä»¥å–çš„æ¬¡æ•°æœ‰ä¸€ä¸ªä¸Šé™ï¼ˆå¤šé‡èƒŒåŒ…ï¼‰ã€‚åº”è¯¥æ€ä¹ˆæ±‚è§£å‘¢ï¼Ÿ

è€ƒè™‘åˆ°åœ¨P01å’ŒP02ä¸­æœ€åç»™å‡ºçš„ä¼ªä»£ç åªæœ‰ä¸€å¤„ä¸åŒï¼Œæ•…å¦‚æœåªæœ‰ä¸¤ç±»ç‰©å“ï¼šä¸€ç±»ç‰©å“åªèƒ½å–ä¸€æ¬¡ï¼Œå¦ä¸€ç±»ç‰©å“å¯ä»¥å–æ— é™æ¬¡ï¼Œé‚£ä¹ˆåªéœ€åœ¨å¯¹æ¯ä¸ªç‰©å“åº”ç”¨è½¬ç§»æ–¹ç¨‹æ—¶ï¼Œæ ¹æ®ç‰©å“çš„ç±»åˆ«é€‰ç”¨é¡ºåºæˆ–é€†åºçš„å¾ªç¯å³å¯ï¼Œå¤æ‚åº¦æ˜¯O(VN)ã€‚ä¼ªä»£ç å¦‚ä¸‹ï¼š

for i=1..N
if ç¬¬iä»¶ç‰©å“æ˜¯01èƒŒåŒ…
for v=V..0
f[v]=max{f[v],f[v-c[i]]+w[i]};
else if ç¬¬iä»¶ç‰©å“æ˜¯å®Œå…¨èƒŒåŒ…
for v=0..V
f[v]=max{f[v],f[v-c[i]]+w[i]};





åŠ¨æ€è§„åˆ’å¯èƒ½ä¼šæœ‰ä»€ä¹ˆä¸è¶³





æ‰‹æ’•ï¼šæ¨¡æ‹ŸLinuxå‘½ä»¤è¡Œè·¯å¾„å‹ç¼©ï¼Œèµ·åˆé¢˜ç›®çœ‹ä¸å¤ªæ‡‚ï¼Œç„¶åé¢è¯•ä¹Ÿéå¸¸ç»†å¿ƒåœ°è§£é‡Šäº†ã€‚ 

  ../è¡¨ç¤ºä¸Šçº§ç›®å½• ./è¡¨ç¤ºå½“å‰ç›®å½• 

  æ¯”å¦‚ 

  /a/b/c/../d -> /a/b/d 

  /a/b/c/././../../e -> /a/e

```java
//ç”¨æ ˆ
public static String dirCompression(String path){

    if (path==null|| path.length()==0)
        return "";
    String[] dirs=path.split("/");
    Stack stack =new Stack();
    for (int i=0;i<dirs.length;i++){
        if (dirs[i].equals(".")){
            continue;
        }
        else if (dirs[i].equals("..")){
            if (!stack.isEmpty()){
                stack.pop();
            }
        }else {
            stack.push(dirs[i]);
        }
    }

    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()){
        sb.insert(0,stack.pop()+"/");
    }

    return sb.substring(0,sb.length()-1);


}
```



æ‰‹æ’•ï¼šæ ‘çš„å±‚æ¬¡éå†ï¼Œå°±æ­£å¸¸åœ°ç”¨BFSå†™äº†ä¸‹æ¥ï¼Œé€»è¾‘æ²¡æœ‰é—®é¢˜ã€‚ä½†åæ¥è¯´æˆ‘å¼€æ”¾çš„æ¥å£ä¸å¤Ÿï¼Œè€ƒè™‘çš„ä¸å¤Ÿã€‚

**éå†æŠ€å·§ä¸€ï¼š æ•°ç»„é•¿åº¦åšéš”ç¦»**

æ€è·¯ï¼š

è·å–å½“å‰çš„é˜Ÿåˆ—çš„é•¿åº¦lengthï¼Œä¸€æ¬¡åªéå†lengthä¸ªèŠ‚ç‚¹ï¼Œåç»­åŠ å…¥çš„å…ƒç´ åœ¨ä¸‹ä¸€æ¬¡å¾ªç¯éå†ã€‚

ä¼ªä»£ç å¦‚ä¸‹ï¼š

```
1 queue =  [node]  // æ–°å»ºä¸€ä¸ªé˜Ÿåˆ—ï¼Œå¹¶å°†æ ¹èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—
2 while queue.lengh != 0
3     length = queue.length //  è·å–å½“å‰é˜Ÿåˆ—çš„é•¿åº¦
4     while length > 0        // åªå¼¹å‡ºlength ä¸ªèŠ‚ç‚¹
5         item = queue.shift // å¼¹å‡ºé˜Ÿåˆ—çš„å¤´éƒ¨å…ƒç´ 
6         do_something(item)    //  æ“ä½œè¯¥èŠ‚ç‚¹ï¼šæ¯”å¦‚å­˜å…¥ä¸€ä¸ªæ•°ç»„æˆ–è€…æ‰“å°
7         queue.push(item.left)  if item.left  // å°†å·¦å­èŠ‚ç‚¹å­˜å…¥é˜Ÿåˆ—
8         queue.push(item.right) if item.right  // å°†å³å­èŠ‚ç‚¹å­˜å…¥é˜Ÿåˆ—
9         length--
```



**éå†æŠ€å·§äºŒï¼šä½¿ç”¨åˆ†éš”ç¬¦**

æ€è·¯

åœ¨ä¸åŒçš„èŠ‚ç‚¹ä¸­é—´åŠ å…¥ä¸€ä¸ªåˆ†éš”ç¬¦ï¼Œéå†å‘å“¦åˆ†å‰²å‡ ç‚¹çš„æ—¶å€™ï¼Œåœæ­¢å½“å‰éå†ã€‚

ä¼ªä»£ç å¦‚ä¸‹ï¼š

```
1 queue = [node]     // æ–°å»ºä¸€ä¸ªé˜Ÿåˆ—ï¼Œå¹¶å°†æ ¹èŠ‚ç‚¹æ”¾å…¥åˆ°é˜Ÿåˆ—
2 while queue.lengh != 0
3     queue.push "$"    // å°†åˆ†å‰²ç¬¦æ”¾å…¥é˜Ÿåˆ—
4     while(true)           // åšä¸€ä¸ªæ— é™å¾ªç¯
5            item = queue.shift   // å¼¹å‡ºé˜Ÿåˆ—çš„å¤´éƒ¨å…ƒç´ 
6            break if item == '$'   // å¦‚æœå½“å‰çš„èŠ‚ç‚¹ç­‰äºåˆ†éš”ç¬¦ï¼Œè¯´æ˜è¯¥å±‚å·²ç»éå†åˆ°äº†æœ€å³è¾¹
7            do_something(item)  //æ“ä½œè¯¥èŠ‚ç‚¹
8            queue.push(item.left)  if item.left // å°†å·¦å­èŠ‚ç‚¹å­˜å…¥é˜Ÿåˆ—
9            queue.push(item.right)  if item.right // å°†å³å­èŠ‚ç‚¹å­˜å…¥é˜Ÿåˆ—
```





æ‰‹å†™äºŒå‰æ ‘ã€æ•°ç»„å…¨æ’åˆ—ã€‚

* é€’å½’ä¼šé€ æˆè¿‡æ·±çš„æ ˆæ·±åº¦
* è€ƒè™‘é‡å¤å…ƒç´ 

```java
public class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(nums==null || nums.length==0) return res;
      //åˆ¤æ–­æ˜¯å¦æœ‰é‡å¤
        boolean[] used = new boolean[nums.length];
        List<Integer> list = new ArrayList<Integer>();
        Arrays.sort(nums);
        dfs(nums, used, list, res);
        return res;
    }

    public void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res){
        if(list.size()==nums.length){
            res.add(new ArrayList<Integer>(list));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(used[i]) continue;
            if(i>0 &&nums[i-1]==nums[i] && !used[i-1]) continue;
            used[i]=true;
            list.add(nums[i]);
            dfs(nums,used,list,res);
            used[i]=false;
            list.remove(list.size()-1);
        }
    }
}
```



æ’•äº†ä¸€ä¸ªç©¿è¿‡æœ€å°‘ç –å¤´çš„é¢˜ï¼Œä¸ç®—éš¾ã€‚ä¸€ä¸ªæœ€é•¿å›æ–‡å­ä¸²ï¼Œdp



 æœ€é•¿å…¬å…±å­ä¸² åˆ¤æ–­ä¸¤å­—ç¬¦ä¸²ä¸­æ˜¯å¦å­—ç¬¦ç›¸åŒï¼Œé¡ºåºä¸åŒ



ä¸¤é“æ•°ç»„çš„ç®—æ³•é¢˜ï¼Œå¾ˆç®€å•ï¼ŒæŠŠleetcodeæ•°ç»„éƒ¨åˆ†çš„åšåšå°±å¥½



éšä¾¿å†™ä¸ªæ’åº æˆ‘å†™çš„å¿«æ’



ä»æ•°ç»„ä¸­æŸ¥æ‰¾æŸä¸ªæ•°k æŸ¥åˆ°è¿”å›index å¦åˆ™è¿”å›0



æ‰‹æ’•ä»£ç :ç»™å®šä¸€å®šé‡‘é¢ï¼Œæœ‰ä¸‰æ ·å•†å“ï¼Œæœ‰å¤šå°‘ç§ä¹°æ³•èƒ½æ°å¥½èŠ±å®Œ

æ‰‹æ’•ä»£ç :å­—ç¬¦ä¸²så’Œpï¼Œåœ¨sä¸­åˆ é™¤æœ€å°‘çš„å­—ç¬¦ï¼Œä½¿pä¸ºsçš„å­ä¸²

æ‰‹æ’•ä»£ç æ˜¯æ¡¶æ’åº

æ‰‹æ’•ä»£ç  æ•°ç»„ä¸­é™¤äº†ä¸¤ä¸ªæ•°åªå‡ºç°äº†ä¸€æ¬¡ï¼Œå…¶ä½™éƒ½å‡ºç°äº†ä¸¤æ¬¡ï¼Œæ‰¾åˆ°è¿™ä¸¤ä¸ªæ•° å‰‘æŒ‡offeråŸé¢˜

æ‰‹æ’•ä»£ç ï¼Œç»™ä¸€ä¸ªå¾ˆå¤§çš„æ•°ï¼Œæ¯”å¦‚9534532679ï¼Œæ‰¾æœ€å¤§é€’å‡æ•°ï¼Œæ¯”å¦‚è¿™ä¸ªä¾‹å­å°±æ˜¯953

æ‰‹æ’•å•é“¾è¡¨çš„æ’åºï¼Œè§„å®šç”¨ç›´æ¥æ’å…¥æ’åºï¼Œåœ¨åŸé“¾è¡¨ä¿®æ”¹

æ‰‹æ’•ä»£ç ï¼šå‰‘æŒ‡offerï¼Œè½¬åœˆå‰”é™¤å­¦ç”Ÿ

å¦‚ä½•ç”¨æ•°ç»„å®ç°ä¸€ä¸ªç¯

æ‰‹æ’•ä»£ç ï¼šæ•°ç»„ä¸­ä¸é‡å¤å…ƒç´ çš„ä¸ªæ•°ï¼Œæ•°ç»„æœ‰åºï¼Œç©ºé—´å¤æ‚åº¦ä¸º1

äºŒåˆ†æŸ¥æ‰¾ï¼Œå†™äº†ä¸ªé€’å½’ç‰ˆçš„ï¼Œç„¶ååˆè®©å†™ä¸ªå¾ªç¯ç‰ˆçš„ã€‚

ä¸Šæ¥å…ˆå†™ä¸€ä¸ªï¼Œæ±‚ä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹çš„æœ€å¤§å€¼ã€‚æˆ‘ç”¨å…ˆåºéå†å†™äº†ä¸€ä¸ªã€‚

ç„¶ååŠ å¼ºç‰ˆï¼Œæ±‚ä¸€ä¸ªäºŒå‰æ ‘ç¬¬kå¤§çš„èŠ‚ç‚¹å€¼ï¼Œæˆ‘ç”¨å°é¡¶å †+å…ˆåºéå†å†™äº†ä¸€ä¸ª

.æ‰‹æ’•ï¼šå†™ä¸€ä¸ªåŒå‘é“¾è¡¨ç»“æ„ã€å†™ä¸€ä¸ªåŒå‘é“¾è¡¨çš„æ’å…¥å‡½æ•°







æœ‰ä¸¤ä¸ªæ¯”è¾ƒå¤§çš„æ•°ç»„ï¼Œè®©æ±‚å®ƒä»¬çš„äº¤é›†ã€‚ï¼ˆå½“æ—¶ä¹Ÿæ²¡æœ‰é™åˆ¶è¯´æ—¶ç©ºå¤æ‚åº¦è¦æ€ä¹ˆæ ·ï¼‰å°±è¯´ä½ å…ˆæƒ³æƒ³ï¼Œä¹Ÿå¯ä»¥å’Œæˆ‘äº¤æµã€‚ 

  æƒ³äº†ä¸€ä¼šå„¿ï¼ˆå½“æ—¶ä¸çŸ¥é“ä¸ºå•¥ï¼Œå®Œå…¨æ²¡æƒ³åˆ°ç”¨hashåšã€‚ã€‚ï¼‰ï¼Œå°±è¯´äº†ä¸€ä¸ªæŠŠå…¶ä¸­ä¸€ä¸ªæ’åºï¼Œå†éå†å¦ä¸€ä¸ªå»äºŒåˆ†æŸ¥æ‰¾çš„æ€è·¯ã€‚



CAP å’Œ BASE

CAPç†è®ºä¸ºï¼šä¸€ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿæœ€å¤šåªèƒ½åŒæ—¶æ»¡è¶³ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰ã€å¯ç”¨æ€§ï¼ˆAvailabilityï¼‰å’Œåˆ†åŒºå®¹é”™æ€§ï¼ˆPartition toleranceï¼‰è¿™ä¸‰é¡¹ä¸­çš„ä¸¤é¡¹ã€‚

## 1.1 ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰

ä¸€è‡´æ€§æŒ‡â€œall nodes see the same data at the same timeâ€ï¼Œå³æ›´æ–°æ“ä½œæˆåŠŸå¹¶è¿”å›å®¢æˆ·ç«¯å®Œæˆåï¼Œæ‰€æœ‰èŠ‚ç‚¹åœ¨åŒä¸€æ—¶é—´çš„æ•°æ®å®Œå…¨ä¸€è‡´ã€‚

## 1.2 å¯ç”¨æ€§ï¼ˆAvailabilityï¼‰

å¯ç”¨æ€§æŒ‡â€œReads and writes always succeedâ€ï¼Œå³æœåŠ¡ä¸€ç›´å¯ç”¨ï¼Œè€Œä¸”æ˜¯æ­£å¸¸å“åº”æ—¶é—´ã€‚

## 1.3 åˆ†åŒºå®¹é”™æ€§ï¼ˆPartition toleranceï¼‰

åˆ†åŒºå®¹é”™æ€§æŒ‡â€œthe system continues to operate despite arbitrary message loss or failure of part of the systemâ€ï¼Œå³åˆ†å¸ƒå¼ç³»ç»Ÿåœ¨é‡åˆ°æŸèŠ‚ç‚¹æˆ–ç½‘ç»œåˆ†åŒºæ•…éšœçš„æ—¶å€™ï¼Œä»ç„¶èƒ½å¤Ÿå¯¹å¤–æä¾›æ»¡è¶³ä¸€è‡´æ€§å’Œå¯ç”¨æ€§çš„æœåŠ¡ã€‚



BASEç†è®ºæ˜¯å¯¹CAPç†è®ºçš„å»¶ä¼¸ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯å³ä½¿æ— æ³•åšåˆ°å¼ºä¸€è‡´æ€§ï¼ˆStrong Consistencyï¼ŒCAPçš„ä¸€è‡´æ€§å°±æ˜¯å¼ºä¸€è‡´æ€§ï¼‰ï¼Œä½†åº”ç”¨å¯ä»¥é‡‡ç”¨é€‚åˆçš„æ–¹å¼è¾¾åˆ°æœ€ç»ˆä¸€è‡´æ€§ï¼ˆEventual Consitencyï¼‰ã€‚

BASEæ˜¯æŒ‡åŸºæœ¬å¯ç”¨ï¼ˆBasically Availableï¼‰ã€è½¯çŠ¶æ€ï¼ˆ Soft Stateï¼‰ã€æœ€ç»ˆä¸€è‡´æ€§ï¼ˆ Eventual Consistencyï¼‰ã€‚

## 3.1 åŸºæœ¬å¯ç”¨ï¼ˆBasically Availableï¼‰

åŸºæœ¬å¯ç”¨æ˜¯æŒ‡åˆ†å¸ƒå¼ç³»ç»Ÿåœ¨å‡ºç°æ•…éšœçš„æ—¶å€™ï¼Œå…è®¸æŸå¤±éƒ¨åˆ†å¯ç”¨æ€§ï¼Œå³ä¿è¯æ ¸å¿ƒå¯ç”¨ã€‚

ç”µå•†å¤§ä¿ƒæ—¶ï¼Œä¸ºäº†åº”å¯¹è®¿é—®é‡æ¿€å¢ï¼Œéƒ¨åˆ†ç”¨æˆ·å¯èƒ½ä¼šè¢«å¼•å¯¼åˆ°é™çº§é¡µé¢ï¼ŒæœåŠ¡å±‚ä¹Ÿå¯èƒ½åªæä¾›é™çº§æœåŠ¡ã€‚è¿™å°±æ˜¯æŸå¤±éƒ¨åˆ†å¯ç”¨æ€§çš„ä½“ç°ã€‚

## 3.2 è½¯çŠ¶æ€ï¼ˆ Soft Stateï¼‰

è½¯çŠ¶æ€æ˜¯æŒ‡å…è®¸ç³»ç»Ÿå­˜åœ¨ä¸­é—´çŠ¶æ€ï¼Œè€Œè¯¥ä¸­é—´çŠ¶æ€ä¸ä¼šå½±å“ç³»ç»Ÿæ•´ä½“å¯ç”¨æ€§ã€‚åˆ†å¸ƒå¼å­˜å‚¨ä¸­ä¸€èˆ¬ä¸€ä»½æ•°æ®è‡³å°‘ä¼šæœ‰ä¸‰ä¸ªå‰¯æœ¬ï¼Œå…è®¸ä¸åŒèŠ‚ç‚¹é—´å‰¯æœ¬åŒæ­¥çš„å»¶æ—¶å°±æ˜¯è½¯çŠ¶æ€çš„ä½“ç°ã€‚mysql replicationçš„å¼‚æ­¥å¤åˆ¶ä¹Ÿæ˜¯ä¸€ç§ä½“ç°ã€‚

## 3.3 æœ€ç»ˆä¸€è‡´æ€§ï¼ˆ Eventual Consistencyï¼‰

æœ€ç»ˆä¸€è‡´æ€§æ˜¯æŒ‡ç³»ç»Ÿä¸­çš„æ‰€æœ‰æ•°æ®å‰¯æœ¬ç»è¿‡ä¸€å®šæ—¶é—´åï¼Œæœ€ç»ˆèƒ½å¤Ÿè¾¾åˆ°ä¸€è‡´çš„çŠ¶æ€ã€‚å¼±ä¸€è‡´æ€§å’Œå¼ºä¸€è‡´æ€§ç›¸åï¼Œæœ€ç»ˆä¸€è‡´æ€§æ˜¯å¼±ä¸€è‡´æ€§çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚





ACIDæ˜¯ä¼ ç»Ÿæ•°æ®åº“å¸¸ç”¨çš„è®¾è®¡ç†å¿µï¼Œè¿½æ±‚å¼ºä¸€è‡´æ€§æ¨¡å‹ã€‚BASEæ”¯æŒçš„æ˜¯å¤§å‹åˆ†å¸ƒå¼ç³»ç»Ÿï¼Œæå‡ºé€šè¿‡ç‰ºç‰²å¼ºä¸€è‡´æ€§è·å¾—é«˜å¯ç”¨æ€§ã€‚

ACIDå’ŒBASEä»£è¡¨äº†ä¸¤ç§æˆªç„¶ç›¸åçš„è®¾è®¡å“²å­¦

åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡çš„åœºæ™¯ä¸­ï¼Œç³»ç»Ÿç»„ä»¶å¯¹ä¸€è‡´æ€§è¦æ±‚æ˜¯ä¸åŒçš„ï¼Œå› æ­¤ACIDå’ŒBASEåˆä¼šç»“åˆä½¿ç”¨ã€‚



 Reids é›†ç¾¤é€‰ä¸¾ï¼Œå¿ƒè·³æ£€æµ‹

### å¿ƒè·³æ£€æµ‹

åœ¨å‘½ä»¤ä¼ æ’­é˜¶æ®µï¼Œ**ä»æœåŠ¡å™¨é»˜è®¤ä»¥æ¯ç§’ä¸€æ¬¡çš„é¢‘ç‡**ï¼Œå‘ä¸»æœåŠ¡å™¨å‘é€å‘½ä»¤ï¼š

**REPLCONF ACK <replication_offset>** //replication_offsetæ˜¯ä»æœåŠ¡å™¨å½“å‰çš„å¤åˆ¶åç§»é‡ã€‚

å¿ƒè·³æ£€æµ‹çš„ä½œç”¨ï¼šæ£€æµ‹ä¸»æœåŠ¡å™¨çš„ç½‘ç»œè¿æ¥çŠ¶æ€ï¼›è¾…åŠ©å®ç°min-slavesé€‰é¡¹ï¼›æ£€æµ‹å‘½ä»¤ä¸¢å¤±ã€‚

æ£€æµ‹ä¸»ä»æœåŠ¡å™¨çš„ç½‘ç»œè¿æ¥çŠ¶æ€

é€šè¿‡å‘ä¸»æœåŠ¡å™¨å‘é€INFO replicationå‘½ä»¤ï¼Œå¯ä»¥åˆ—å‡ºä»æœåŠ¡å™¨åˆ—è¡¨ï¼Œå¯ä»¥çœ‹å‡ºä»æœ€åä¸€æ¬¡å‘ä¸»å‘é€å‘½ä»¤è·ç¦»ç°åœ¨è¿‡äº†å¤šå°‘ç§’ã€‚

lagçš„å€¼åº”è¯¥åœ¨0æˆ–1ä¹‹é—´è·³åŠ¨ï¼Œå¦‚æœè¶…è¿‡1åˆ™è¯´æ˜ä¸»ä»ä¹‹é—´çš„è¿æ¥æœ‰æ•…éšœã€‚

è¾…åŠ©å®ç°min-slavesé€‰é¡¹

Rediså¯ä»¥é€šè¿‡é…ç½®**é˜²æ­¢ä¸»æœåŠ¡å™¨åœ¨ä¸å®‰å…¨çš„æƒ…å†µä¸‹æ‰§è¡Œå†™å‘½ä»¤**ï¼›

min-slaves-to-write 3

min-slaves-max-lag 10

ä¸Šé¢çš„é…ç½®è¡¨ç¤ºï¼šä»æœåŠ¡å™¨çš„æ•°é‡å°‘äº3ä¸ªï¼Œæˆ–è€…ä¸‰ä¸ªä»æœåŠ¡å™¨çš„å»¶è¿Ÿï¼ˆlagï¼‰å€¼éƒ½å¤§äºæˆ–ç­‰äº10ç§’æ—¶ï¼Œä¸»æœåŠ¡å™¨å°†æ‹’ç»æ‰§è¡Œå†™å‘½ä»¤ã€‚è¿™é‡Œçš„å»¶è¿Ÿå€¼å°±æ˜¯ä¸Šé¢INFOreplicationå‘½ä»¤çš„lagå€¼ã€‚

æ£€æµ‹å‘½ä»¤ä¸¢å¤±

å¦‚æœå› ä¸ºç½‘ç»œæ•…éšœï¼Œä¸»æœåŠ¡å™¨ä¼ æ’­ç»™ä»æœåŠ¡å™¨çš„**å†™å‘½ä»¤åœ¨åŠè·¯ä¸¢å¤±**ï¼Œé‚£ä¹ˆå½“ä»æœåŠ¡å™¨å‘ä¸»æœåŠ¡å™¨å‘é€REPLCONF ACKå‘½ä»¤æ—¶ï¼Œä¸»æœåŠ¡å™¨å°†å‘è§‰ä»æœåŠ¡å™¨å½“å‰çš„**å¤åˆ¶åç§»é‡**å°‘äºè‡ªå·±çš„å¤åˆ¶åç§»é‡ï¼Œç„¶åä¸»æœåŠ¡å™¨å°±ä¼šæ ¹æ®ä»æœåŠ¡å™¨æäº¤çš„å¤åˆ¶åç§»é‡ï¼Œåœ¨å¤åˆ¶ç§¯å‹ç¼“å†²åŒºé‡Œé¢æ‰¾åˆ°ä»æœåŠ¡å™¨ç¼ºå°‘çš„æ•°æ®ï¼Œå¹¶å°†è¿™äº›æ•°æ®é‡æ–°å‘é€ç»™ä»æœåŠ¡å™¨ã€‚

ä¸»æœåŠ¡å™¨å‘ä»æœåŠ¡å™¨**è¡¥å‘ç¼ºå¤±æ•°æ®**è¿™ä¸€æ“ä½œçš„åŸç†å’Œéƒ¨åˆ†é‡åŒæ­¥æ“ä½œçš„åŸç†éå¸¸ç›¸ä¼¼ï¼Œå®ƒä»¬çš„åŒºåˆ«åœ¨äºï¼šè¡¥å‘ç¼ºå¤±æ•°æ®æ“ä½œåœ¨ä¸»ä»æœåŠ¡å™¨æ²¡æœ‰æ–­çº¿çš„æƒ…å†µä¸‹æ‰§è¡Œï¼Œè€Œéƒ¨åˆ†é‡åŒæ­¥æ“ä½œåˆ™åœ¨ä¸»ä»æœåŠ¡å™¨æ–­çº¿å¹¶é‡è¿ä¹‹åæ‰§è¡Œã€‚









åˆ†åº“åˆ†è¡¨ï¼Œæ•°æ®åº“äº‹åŠ¡ï¼Œåˆ†å¸ƒå¼äº‹åŠ¡





æ“ä½œç³»ç»Ÿäº†è§£è¯´ï¼Œè¯´ä¸€ä¸‹ä½ è®¾è®¡æ“ä½œç³»ç»Ÿè¦å‡ ä¸ªæ¨¡å—ã€‚
ï¼ˆç£ç›˜ç®¡ç†  çº¿ç¨‹ç®¡ç†  IOç®¡ç†  æ–‡ä»¶ç®¡ç†ï¼‰

æœ‰æ²¡æœ‰ç”¨è¿‡æ•°æ®åº“ ï¼Œ æ€ä¹ˆå»è¿ ã€‚ å“ªå‡ ä¸ªæ­¥éª¤ï¼Ÿ è¯´ä¸€ä¸‹ã€‚ æ•°æ®åº“è¿æ¥æ± äº†è§£å—ï¼Œ æœ‰ä»€ä¹ˆå¥½å¤„ï¼Ÿæœ‰æ²¡æœ‰å†™è¿‡å¤æ‚sql  æ¸¸æ ‡äº†è§£å—



çº¿ä¸Šçš„é—®é¢˜ï¼Œå¦‚ä½•å»æ’æŸ¥ï¼Œ æ€ä¹ˆå»çœ‹åˆ°å½“å‰ç¨‹åºè¿è¡Œçš„çŠ¶æ€ã€‚

æ•°æ®åº“æŸ¥è¯¢æ…¢æ˜¯ä»€ä¹ˆåŸå› ã€‚

gdpæ€ä¹ˆæ¥åˆ‡æ¢çº¿ç¨‹

è®²è®²å…±äº«å†…å­˜åŸç†

:è¿›ç¨‹Aå’ŒBçš„åœ°å€éƒ½æ˜¯0xabcd123ï¼Œä¼šä¸ä¼šç›¸äº’è®¿é—®ï¼Œä¸ºä»€ä¹ˆ

epollå’Œselect pollçš„åŒºåˆ«ï¼Œå¼€å§‹è®²æºç ç„¶åè®²äº†ä¸€ä¼šä»–è®©æˆ‘åœäº†...è¯´å¯ä»¥äº†

æ­£å‘ä»£ç†å’Œåå‘ä»£ç†





å¿«æ’åŸç†

å½’å¹¶æ’åºåŸç†

å†’æ³¡æ’åºç¨³å®šå—



è¯´ä¸‹è‡ªå·±å¯¹  Zookeeper çš„ç†è§£å·²ç»åœ¨é¡¹ç›®ä¸­æ˜¯å¦‚ä½•åº”ç”¨çš„ï¼Œè‡ªå·±æ‰¯ ZABï¼Œå·²ç» ZK åœ¨ Dubbo åšæ³¨å†Œä¸­å¿ƒï¼Œåœ¨ Kafka ä¸­åšé›†ç¾¤ç®¡ç†ï¼Œè¿˜æœ‰åˆ†å¸ƒå¼é”å®ç°ï¼Œé›†ç¾¤é€‰ä¸¾ Raft å’Œ Paxos åŒºåˆ«å·²ç»å…·ä½“çš„æµç¨‹

<https://www.cnblogs.com/bangerlee/p/5991417.html>





GC è°ƒä¼˜ 

é¡¹ç›®ä¸­ç”¨è¿‡åˆ°çš„ç®—æ³•å’Œæ•°æ®ç»“æ„ï¼Œè®²äº†ä¸‹ Redis ZSET å’Œ èšç¾¤ç®—æ³•