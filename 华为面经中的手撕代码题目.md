# 华为面经中的手撕代码题目

两个字符串，第一个去掉哪些字符后，它的子字符串能和另一个匹配。

双指针，按字符匹配。



有总面积是N*N的岛和海洋两种地形，1表示岛，0是海。问距离岛屿最远的海洋是哪个，距离是多少？距离用什么公式（忘了名字）= |  x0-x1| + |y0-y1  | 

  例子1 

  1 0 1 

  0 0 0 

  1 0 1 

  海洋位置就是（1,1），距离为2 

  


  例子2 

  1 0 0 

  0 0 0 

  0 0 0 

  海洋位置就是（2,2）距离是4

```java
int[][] directions = new int[][] {{-1, 0},{1,0},{0,-1},{0,1}};
public int maxDistance(int[][] grid) {
    if(grid == null || grid.length == 0 || grid[0].length == 0)return -1;
    boolean[][] visited = new boolean[grid.length][grid[0].length];
    Queue<int[]> queue = new ArrayDeque<>();

    for(int i = 0 ; i < grid.length ; i++) {
        for(int j = 0 ; j < grid[0].length ; j++) {
            //所有的岛屿都入队列
            if(grid[i][j] == 1) {
                queue.offer(new int[]{i,j});
                visited[i][j] = true;
            }
        }
    }
    //当最终所有的海洋都被visited时，队列中仍然会包含元素，多运行一轮，为了平衡所以level初始化为1。
    int level = -1;
    while(!queue.isEmpty()) {
        int size = queue.size();
        for(int i = 0 ; i < size ; i++) {
            //从当前队列出队一个
            int[] start = queue.poll();
            int x = start[0];
            int y = start[1];
            //遍历它的四周有没有海洋
            for(int[] dir : directions) {
                int newX = x + dir[0];
                int newY = y + dir[1];
                //没有超过边界，且海洋未被visited
                if(newX >= 0 && newX < grid.length && newY >= 0 && newY < grid[0].length
                        && !visited[newX][newY] && grid[newX][newY] == 0) {
                    //置为visited
                    visited[newX][newY] = true;
                    //新的点visited
                    queue.offer(new int[]{newX, newY});
                }
            }
        }
        //所有已visited的海洋 或者 岛屿 都朝周围的 未探索的海洋 迈进了一步，level++；
        level++;
    }
    return level <= 0 ? -1 : level;
}
```



代码:三数之和，时间复杂度   代码题目：从一串数字中找出所有的相加为0的三个数字。

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    if (nums==null||nums.length==0){
        return list;
    }
    Arrays.sort(nums);

    for (int i=0; i<nums.length-2; i++){

        if (i==0||(i>0&&nums[i]!=nums[i-1])) {
            int lo = i + 1, hi = nums.length - 1, sum = -nums[i];

            while (lo < hi) {
                if (sum == nums[lo] + nums[hi]) {
                    list.add(Arrays.asList(nums[i], nums[lo], nums[hi]));
                    while (lo < hi && nums[lo] == nums[lo + 1]) lo++;
                    while (lo < hi && nums[hi] == nums[hi - 1]) hi--;
                    lo++;
                    hi--;
                } else {
                    if (sum < nums[lo] + nums[hi]) hi--;
                    else lo++;
                }
            }
        }
    }


    return list;
}
```

手撕判断二叉树是否相等

```java
public boolean sameTree(TreeNode p, TreeNode q){
    if (p==null && q==null) return true;
    if (p == null || q == null) return false;
    if (p.val!=q.val) return false;

    return sameTree(p.left,q.left)&&sameTree(p.right,q.right);
}
```



手撕代码，机试最后一题

```java
private static int[][] dirs ={{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};

public static int shortestPathBinaryMatrix(int[][] grid) {

    if (grid==null||grid.length==0||grid[0].length==0){
        return -1;
    }

    if (grid.length==1 && grid[0].length==1){
        return 1;
    }

    if (grid[0][0]==1 || grid[grid.length-1][grid[0].length-1]== 1) {
        return -1;
    }



    boolean[][] visited = new boolean[grid.length][grid[0].length];
    int[][] path= new int[grid.length][grid[0].length];
    for (int i=0; i<grid.length;i++){
        for (int j=0; j<grid[0].length; j++){
            if (grid[i][j] ==1){
                visited[i][j] = true;
            }
        }
    }

    Queue queue = new LinkedList();
    queue.offer(new int[]{0,0});
    visited[0][0]=true;
    int level=1;
    boolean deadCircle=true;
    while (!queue.isEmpty()){
        int size=queue.size();
        for (int k=0; k < size; k++){
            int[] pos = (int[]) queue.poll();
            int x=pos[0];
            int y=pos[1];
            for (int[] dir: dirs){
                int newX=x+dir[0];
                int newY=y+dir[1];
                if (newX>=0 && newX < grid.length && newY>=0 && newY< grid[0].length){

                    if (newX == grid.length-1 && newY == grid[0].length-1){



                        path[newX][newY] = x*grid[0].length+y;

                        int i=grid.length-1,j=grid[0].length-1;
                        StringBuilder sb= new StringBuilder();
                        int posNum;
                        while ((i+j)!=0){
                            sb.insert(0,String.format("->(%s,%s)",i,j));
                            posNum=path[i][j];
                            i=posNum/grid[0].length;
                            j=posNum%grid[0].length;
                        }
                        sb.insert(0, String.format("(%s,%s)", i,j));
                        System.out.println(sb);




                        return level+1;
                    }

                    if (visited[newX][newY] == false) {
                        queue.offer(new int[]{newX, newY});
                        visited[newX][newY] = true;
                        path[newX][newY] = x*grid[0].length+y;
                        deadCircle=false;
                    }
                }
            }
        }

        if (deadCircle){
            return -1;
        }
        deadCircle=true;

        level++;
    }


    return -1;
}

```

写一个自己最熟悉的代码？有哪些用途？

最简单的NIO服务器

```java
System.out.println ("Listening on port " + port);

// allocate an unbound server socket channel
ServerSocketChannel serverChannel = ServerSocketChannel.open();
// Get the associated ServerSocket to bind it with
ServerSocket serverSocket = serverChannel.socket();
// create a new Selector for use below
Selector selector = Selector.open();

// set the port the server channel will listen to
serverSocket.bind (new InetSocketAddress (port));

// set non-blocking mode for the listening socket
serverChannel.configureBlocking (false);

// register the ServerSocketChannel with the Selector
serverChannel.register (selector, SelectionKey.OP_ACCEPT);

while (true) {
   // this may block for a long time, upon return the
   // selected set contains keys of the ready channels
   int n = selector.select();

   if (n == 0) {
      continue;  // nothing to do
   }

   // get an iterator over the set of selected keys
   Iterator it = selector.selectedKeys().iterator();

   // look at each key in the selected set
   while (it.hasNext()) {
      SelectionKey key = (SelectionKey) it.next();

      // Is a new connection coming in?
      if (key.isAcceptable()) {
         ServerSocketChannel server =
            (ServerSocketChannel) key.channel();
         SocketChannel channel = server.accept();

         registerChannel (selector, channel,
            SelectionKey.OP_READ);

         sayHello (channel);
      }

      // is there data to read on this channel?
      if (key.isReadable()) {
         readDataFromSocket (key);
      }

      // remove key from selected set, it's been handled
      it.remove();
   }
}
```

一上来直接写排序（但是写那个自己决定），边聊边写；

手写快速排序，分析四次运行排序之后的情况

四次运动排序，

```java
    /**
     * 堆排序：
     * 1.构建一个大顶堆；
     * 2.逐步将每个最大值的根结点与末尾元素交换，并再调整其成为大顶堆。
     * @param array
     */
    public static void heapSort(int[] array){
        int i;
        for (i=array.length/2-1;i>=0;i--){
            heapAdjust(array,i,array.length);
        }
        for (i=array.length-1;i>0;i--){
            swap(array,0,i);
            heapAdjust(array,0,i-1);
        }
    }
    private static void heapAdjust(int[] array, int nodeToAdjust,int maxIndex){
        int temp=array[nodeToAdjust];
//        对于初始化一个大顶堆，
//        注意到在heapSort中从length/2-1这个结点开始往根结点实现大顶堆，
//        length/2-1是一个叶子结点的父节点，对于这样的结点，次函数很明显会满足实现；
//        在逐步往根结点推进，直到整个数组满足一个大顶堆。
//        对于交换结点后重新调整为大顶堆：
//        注意，不同于重新构建一个大顶堆，因为除了nodeToAdjust，其他结点都是满足大顶堆要求的。
//        看孩子结点有没有比它大的，如果没有，退出循环；如果有，把孩子结点的值赋给该结点，并且孩子结点称为新的需要调整的结点。
        for (int i=2*nodeToAdjust+1;i<=maxIndex;i=2*i+1){
            if (i<maxIndex&&array[i]<array[i+1]){
                i++;
            }
            if (temp>=array[i]){
                break;
            }
            array[nodeToAdjust]=array[i];
            nodeToAdjust=i;
        }
        array[nodeToAdjust]=temp;

    }


    /**
     * 归并排序：
     * 时间复杂度为O(nlogn)
     最开始只比较两个数
     */
    public static void merSort(int[] arr,int left,int right){

        if(left<right){
            int mid = (left+right)/2;
            merSort(arr,left,mid);//左边归并排序，使得左子序列有序
            merSort(arr,mid+1,right);//右边归并排序，使得右子序列有序
            merge(arr,left,mid,right);//合并两个子序列
        }
    }
    private static void merge(int[] arr, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];//ps：也可以从开始就申请一个与原数组大小相同的数组，因为重复new数组会频繁申请内存
        int i = left;
        int j = mid+1;
        int k = 0;
        while(i<=mid&&j<=right){
            if (arr[i] < arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        while(i<=mid){//将左边剩余元素填充进temp中
            temp[k++] = arr[i++];
        }
        while(j<=right){//将右序列剩余元素填充进temp中
            temp[k++] = arr[j++];
        }
        //将temp中的元素全部拷贝到原数组中
        for (int k2 = 0; k2 < temp.length; k2++) {
            arr[k2 + left] = temp[k2];
        }
    }



/**
     * 快速排序，时间复杂度O(nlogn),空间复杂度O(logn)
     * 快速排序是一种不稳定的排序方法。
     * 优化：
     * 1.三数取中，优化选取枢轴
     * 2.优化不必要的交换
     * 3.小数组时，采用插入排序
     * 4.递归转成迭代，缩短堆栈深度
     * @param array
     */
    public static void quickSort(int[] array){
        qSort(array,0,array.length-1);
    }
    private static void qSort(int[] array,int low,int high){
        //枢轴值
        int pivot;
        //3.小数组时采用插入排序
//        if (low<high){
//            pivot=partition(array,low,high);
//            qSort(array,low,pivot-1);
//            qSort(array,pivot+1,high);
//        }
        if (high-low>MAX_LENGTH_INSER_SORT){
            pivot=partition(array,low,high);
            qSort(array,low,pivot-1);
            qSort(array,pivot+1,high);
        }else
            insertSort(array);
    }
    private static void qSort1(int[] array,int low,int high){
        //枢轴值
        int pivot;
        if (high-low>MAX_LENGTH_INSER_SORT){
            //4.递归转换成迭代，缩减堆栈深度
            while (low<high) {
                pivot = partition(array, low, high);
                qSort1(array, low, pivot - 1);
                low=pivot+1;
            }
        }else
            insertSort(array);
    }
    private static int partition(int[] array,int low,int high) {
        //选取的枢轴，是性能瓶颈

        //1.三数取中：将三个关键字排序，将中间数作为枢轴
        int middle=low+(high-low)/2;
        if (array[low]>array[high])
            swap(array,low,high);
        if (array[middle]>array[high])
            swap(array,high,middle);
        if (array[middle]>array[low])
            swap(array,middle,low);
        int pre=array[low];

        //2.优化不必要的交换
        while (low < high){
            //比枢轴记录小的交换到低端
            while (low < high && array[high] >= pre)
                high--;
//            swap(array, low, high);
            array[low]=array[high];
            //比枢轴记录大的交换到高端
             while (low < high && array[low] <= pre)
                low++;
//            swap(array, low, high);
            array[high]=array[low];
        }
        array[low]=pre;
        return low;
    }

```



链表相乘，就是个位数在链表第一个结点，十位数在链表第二个结点…两个链表相乘，最后输出一个链表

```java
public class LinkedListMultiplication {

    static class ListNode{
        int val;
        ListNode next;

        public ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }

        public ListNode(int val) {
            this.val = val;
        }
    }

    /**
     * 链表相乘，就是个位数在链表第一个结点，十位数在链表第二个结点…两个链表相乘，最后输出一个链表
     * @param p
     * @param q
     * @return
     */
    public static ListNode multiply(ListNode p, ListNode q){
        if (p == null || q == null){
            return null;
        }

        List<Integer> plist= new ArrayList<>(), qlist = new ArrayList<>();
        int count=0;
        while (p!=null){
            plist.add(p.val);
            p=p.next;
            count++;
        }

        while (q!=null){
            qlist.add(q.val);
            q=q.next;
            count++;
        }

        //相乘的结构放到result结果中
        int[] result = new int[count-1];
        for (int i=0;i<plist.size();i++){
            for (int j=0;j<qlist.size();j++){
                result[i+j]+=plist.get(i)*qlist.get(j);
            }
        }

        for (int i=0; i<count-2; i++){
            result[i+1]+=result[i]/10;
            result[i]=result[i]%10;
        }
        ListNode head= new ListNode(result[0]);
        ListNode curr=head;
        for (int i=1; i<count-2; i++){
            curr.next=new ListNode(result[i]);
            curr=curr.next;
        }

        int last=result[count-2];
        while (last!=0){
            curr.next=new ListNode(last%10);
            curr=curr.next;
            last/=10;
        }

        return head;

    }


    public static void main(String[] args) {
        ListNode p=new ListNode(3);
        p.next=new ListNode(2);
        p.next.next=new ListNode(9);


        ListNode q=new ListNode(9);
        q.next=new ListNode(8);
        q.next.next=new ListNode(7);

        multiply(p,q);

    }
}

```



红黑树，可能要了解下

<https://zhuanlan.zhihu.com/p/79980618>



```java
1. 每个节点都有红色或黑色
2. 树的根始终是黑色的 (黑土地孕育黑树根，😄)
3. 没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点）
4. 从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点



红黑树有两大操作:

1. recolor (重新标记黑色或红色)
2. rotation (旋转，这是树达到平衡的关键)

  
  public class RBTree<T extends Comparable<T>> {

    private RBTNode<T> mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode<T extends Comparable<T>> {
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode<T> left;    // 左孩子
        RBTNode<T> right;    // 右孩子
        RBTNode<T> parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode<T> parent, RBTNode<T> left, RBTNode<T> right) {
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

        public T getKey() {
            return key;
        }

        public String toString() {
            return ""+key+(this.color==RED?"(R)":"B");
        }
    }

    public RBTree() {
        mRoot=null;
    }

    private RBTNode<T> parentOf(RBTNode<T> node) {
        return node!=null ? node.parent : null;
    }
    private boolean colorOf(RBTNode<T> node) {
        return node!=null ? node.color : BLACK;
    }
    private boolean isRed(RBTNode<T> node) {
        return ((node!=null)&&(node.color==RED)) ? true : false;
    }
    private boolean isBlack(RBTNode<T> node) {
        return !isRed(node);
    }
    private void setBlack(RBTNode<T> node) {
        if (node!=null)
            node.color = BLACK;
    }
    private void setRed(RBTNode<T> node) {
        if (node!=null)
            node.color = RED;
    }
    private void setParent(RBTNode<T> node, RBTNode<T> parent) {
        if (node!=null)
            node.parent = parent;
    }
    private void setColor(RBTNode<T> node, boolean color) {
        if (node!=null)
            node.color = color;
    }

    /*
     * 前序遍历"红黑树"
     */
    private void preOrder(RBTNode<T> tree) {
        if(tree != null) {
            System.out.print(tree.key+" ");
            preOrder(tree.left);
            preOrder(tree.right);
        }
    }

    public void preOrder() {
        preOrder(mRoot);
    }

    /*
     * 中序遍历"红黑树"
     */
    private void inOrder(RBTNode<T> tree) {
        if(tree != null) {
            inOrder(tree.left);
            System.out.print(tree.key+" ");
            inOrder(tree.right);
        }
    }

    public void inOrder() {
        inOrder(mRoot);
    }


    /*
     * 后序遍历"红黑树"
     */
    private void postOrder(RBTNode<T> tree) {
        if(tree != null)
        {
            postOrder(tree.left);
            postOrder(tree.right);
            System.out.print(tree.key+" ");
        }
    }

    public void postOrder() {
        postOrder(mRoot);
    }


    /*
     * (递归实现)查找"红黑树x"中键值为key的节点
     */
    private RBTNode<T> search(RBTNode<T> x, T key) {
        if (x==null)
            return x;

        int cmp = key.compareTo(x.key);
        if (cmp < 0)
            return search(x.left, key);
        else if (cmp > 0)
            return search(x.right, key);
        else
            return x;
    }

    public RBTNode<T> search(T key) {
        return search(mRoot, key);
    }

    /*
     * (非递归实现)查找"红黑树x"中键值为key的节点
     */
    private RBTNode<T> iterativeSearch(RBTNode<T> x, T key) {
        while (x!=null) {
            int cmp = key.compareTo(x.key);

            if (cmp < 0)
                x = x.left;
            else if (cmp > 0)
                x = x.right;
            else
                return x;
        }

        return x;
    }

    public RBTNode<T> iterativeSearch(T key) {
        return iterativeSearch(mRoot, key);
    }

    /*
     * 查找最小结点：返回tree为根结点的红黑树的最小结点。
     */
    private RBTNode<T> minimum(RBTNode<T> tree) {
        if (tree == null)
            return null;

        while(tree.left != null)
            tree = tree.left;
        return tree;
    }

    public T minimum() {
        RBTNode<T> p = minimum(mRoot);
        if (p != null)
            return p.key;

        return null;
    }

    /*
     * 查找最大结点：返回tree为根结点的红黑树的最大结点。
     */
    private RBTNode<T> maximum(RBTNode<T> tree) {
        if (tree == null)
            return null;

        while(tree.right != null)
            tree = tree.right;
        return tree;
    }

    public T maximum() {
        RBTNode<T> p = maximum(mRoot);
        if (p != null)
            return p.key;

        return null;
    }

    /*
     * 找结点(x)的后继结点。即，查找"红黑树中数据值大于该结点"的"最小结点"。
     */
    public RBTNode<T> successor(RBTNode<T> x) {
        // 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。
        if (x.right != null)
            return minimum(x.right);

        // 如果x没有右孩子。则x有以下两种可能：
        // (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。
        // (02) x是"一个右孩子"，则查找"x的最低的父结点，并且该父结点要具有左孩子"，找到的这个"最低的父结点"就是"x的后继结点"。
        RBTNode<T> y = x.parent;
        while ((y!=null) && (x==y.right)) {
            x = y;
            y = y.parent;
        }

        return y;
    }

    /*
     * 找结点(x)的前驱结点。即，查找"红黑树中数据值小于该结点"的"最大结点"。
     */
    public RBTNode<T> predecessor(RBTNode<T> x) {
        // 如果x存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。
        if (x.left != null)
            return maximum(x.left);

        // 如果x没有左孩子。则x有以下两种可能：
        // (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。
        // (01) x是"一个左孩子"，则查找"x的最低的父结点，并且该父结点要具有右孩子"，找到的这个"最低的父结点"就是"x的前驱结点"。
        RBTNode<T> y = x.parent;
        while ((y!=null) && (x==y.left)) {
            x = y;
            y = y.parent;
        }

        return y;
    }

    /*
     * 对红黑树的节点(x)进行左旋转
     *
     * 左旋示意图(对节点x进行左旋)：
     *      px                              px
     *     /                               /
     *    x                               y
     *   /  \      --(左旋)-.           / \                #
     *  lx   y                          x  ry
     *     /   \                       /  \
     *    ly   ry                     lx  ly
     *
     *
     */
    private void leftRotate(RBTNode<T> x) {
        // 设置x的右孩子为y
        RBTNode<T> y = x.right;

        // 将 “y的左孩子” 设为 “x的右孩子”；
        // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”
        x.right = y.left;
        if (y.left != null)
            y.left.parent = x;

        // 将 “x的父亲” 设为 “y的父亲”
        y.parent = x.parent;

        if (x.parent == null) {
            this.mRoot = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点
        } else {
            if (x.parent.left == x)
                x.parent.left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
            else
                x.parent.right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
        }

        // 将 “x” 设为 “y的左孩子”
        y.left = x;
        // 将 “x的父节点” 设为 “y”
        x.parent = y;
    }

    /*
     * 对红黑树的节点(y)进行右旋转
     *
     * 右旋示意图(对节点y进行左旋)：
     *            py                               py
     *           /                                /
     *          y                                x
     *         /  \      --(右旋)-.            /  \                     #
     *        x   ry                           lx   y
     *       / \                                   / \                   #
     *      lx  rx                                rx  ry
     *
     */
    private void rightRotate(RBTNode<T> y) {
        // 设置x是当前节点的左孩子。
        RBTNode<T> x = y.left;

        // 将 “x的右孩子” 设为 “y的左孩子”；
        // 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”
        y.left = x.right;
        if (x.right != null)
            x.right.parent = y;

        // 将 “y的父亲” 设为 “x的父亲”
        x.parent = y.parent;

        if (y.parent == null) {
            this.mRoot = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点
        } else {
            if (y == y.parent.right)
                y.parent.right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”
            else
                y.parent.left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”
        }

        // 将 “y” 设为 “x的右孩子”
        x.right = y;

        // 将 “y的父节点” 设为 “x”
        y.parent = x;
    }

    /*
     * 红黑树插入修正函数
     *
     * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；
     * 目的是将它重新塑造成一颗红黑树。
     *
     * 参数说明：
     *     node 插入的结点        // 对应《算法导论》中的z
     */
    private void insertFixUp(RBTNode<T> node) {
        RBTNode<T> parent, gparent;

        // 若“父节点存在，并且父节点的颜色是红色”
        while (((parent = parentOf(node))!=null) && isRed(parent)) {
            gparent = parentOf(parent);

            //若“父节点”是“祖父节点的左孩子”
            if (parent == gparent.left) {
                // Case 1条件：叔叔节点是红色
                RBTNode<T> uncle = gparent.right;
                if ((uncle!=null) && isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                }

                // Case 2条件：叔叔是黑色，且当前节点是右孩子
                if (parent.right == node) {
                    RBTNode<T> tmp;
                    leftRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }

                // Case 3条件：叔叔是黑色，且当前节点是左孩子。
                setBlack(parent);
                setRed(gparent);
                rightRotate(gparent);
            } else {    //若“z的父节点”是“z的祖父节点的右孩子”
                // Case 1条件：叔叔节点是红色
                RBTNode<T> uncle = gparent.left;
                if ((uncle!=null) && isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                }

                // Case 2条件：叔叔是黑色，且当前节点是左孩子
                if (parent.left == node) {
                    RBTNode<T> tmp;
                    rightRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }

                // Case 3条件：叔叔是黑色，且当前节点是右孩子。
                setBlack(parent);
                setRed(gparent);
                leftRotate(gparent);
            }
        }

        // 将根节点设为黑色
        setBlack(this.mRoot);
    }

    /*
     * 将结点插入到红黑树中
     *
     * 参数说明：
     *     node 插入的结点        // 对应《算法导论》中的node
     */
    private void insert(RBTNode<T> node) {
        int cmp;
        RBTNode<T> y = null;
        RBTNode<T> x = this.mRoot;

        // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。
        while (x != null) {
            y = x;
            cmp = node.key.compareTo(x.key);
            if (cmp < 0)
                x = x.left;
            else
                x = x.right;
        }

        node.parent = y;
        if (y!=null) {
            cmp = node.key.compareTo(y.key);
            if (cmp < 0)
                y.left = node;
            else
                y.right = node;
        } else {
            this.mRoot = node;
        }

        // 2. 设置节点的颜色为红色
        node.color = RED;

        // 3. 将它重新修正为一颗二叉查找树
        insertFixUp(node);
    }

    /*
     * 新建结点(key)，并将其插入到红黑树中
     *
     * 参数说明：
     *     key 插入结点的键值
     */
    public void insert(T key) {
        RBTNode<T> node=new RBTNode<T>(key,BLACK,null,null,null);

        // 如果新建结点失败，则返回。
        if (node != null)
            insert(node);
    }


    /*
     * 红黑树删除修正函数
     *
     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；
     * 目的是将它重新塑造成一颗红黑树。
     *
     * 参数说明：
     *     node 待修正的节点
     */
    private void removeFixUp(RBTNode<T> node, RBTNode<T> parent) {
        RBTNode<T> other;

        while ((node==null || isBlack(node)) && (node != this.mRoot)) {
            if (parent.left == node) {
                other = parent.right;
                if (isRed(other)) {
                    // Case 1: x的兄弟w是红色的
                    setBlack(other);
                    setRed(parent);
                    leftRotate(parent);
                    other = parent.right;
                }

                if ((other.left==null || isBlack(other.left)) &&
                        (other.right==null || isBlack(other.right))) {
                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                } else {

                    if (other.right==null || isBlack(other.right)) {
                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。
                        setBlack(other.left);
                        setRed(other);
                        rightRotate(other);
                        other = parent.right;
                    }
                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.right);
                    leftRotate(parent);
                    node = this.mRoot;
                    break;
                }
            } else {

                other = parent.left;
                if (isRed(other)) {
                    // Case 1: x的兄弟w是红色的
                    setBlack(other);
                    setRed(parent);
                    rightRotate(parent);
                    other = parent.left;
                }

                if ((other.left==null || isBlack(other.left)) &&
                        (other.right==null || isBlack(other.right))) {
                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                } else {

                    if (other.left==null || isBlack(other.left)) {
                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。
                        setBlack(other.right);
                        setRed(other);
                        leftRotate(other);
                        other = parent.left;
                    }

                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.left);
                    rightRotate(parent);
                    node = this.mRoot;
                    break;
                }
            }
        }

        if (node!=null)
            setBlack(node);
    }

    /*
     * 删除结点(node)，并返回被删除的结点
     *
     * 参数说明：
     *     node 删除的结点
     */
    private void remove(RBTNode<T> node) {
        RBTNode<T> child, parent;
        boolean color;

        // 被删除节点的"左右孩子都不为空"的情况。
        if ( (node.left!=null) && (node.right!=null) ) {
            // 被删节点的后继节点。(称为"取代节点")
            // 用它来取代"被删节点"的位置，然后再将"被删节点"去掉。
            RBTNode<T> replace = node;

            // 获取后继节点
            replace = replace.right;
            while (replace.left != null)
                replace = replace.left;

            // "node节点"不是根节点(只有根节点不存在父节点)
            if (parentOf(node)!=null) {
                if (parentOf(node).left == node)
                    parentOf(node).left = replace;
                else
                    parentOf(node).right = replace;
            } else {
                // "node节点"是根节点，更新根节点。
                this.mRoot = replace;
            }

            // child是"取代节点"的右孩子，也是需要"调整的节点"。
            // "取代节点"肯定不存在左孩子！因为它是一个后继节点。
            child = replace.right;
            parent = parentOf(replace);
            // 保存"取代节点"的颜色
            color = colorOf(replace);

            // "被删除节点"是"它的后继节点的父节点"
            if (parent == node) {
                parent = replace;
            } else {
                // child不为空
                if (child!=null)
                    setParent(child, parent);
                parent.left = child;

                replace.right = node.right;
                setParent(node.right, replace);
            }

            replace.parent = node.parent;
            replace.color = node.color;
            replace.left = node.left;
            node.left.parent = replace;

            if (color == BLACK)
                removeFixUp(child, parent);

            node = null;
            return ;
        }

        if (node.left !=null) {
            child = node.left;
        } else {
            child = node.right;
        }

        parent = node.parent;
        // 保存"取代节点"的颜色
        color = node.color;

        if (child!=null)
            child.parent = parent;

        // "node节点"不是根节点
        if (parent!=null) {
            if (parent.left == node)
                parent.left = child;
            else
                parent.right = child;
        } else {
            this.mRoot = child;
        }

        if (color == BLACK)
            removeFixUp(child, parent);
        node = null;
    }

    /*
     * 删除结点(z)，并返回被删除的结点
     *
     * 参数说明：
     *     tree 红黑树的根结点
     *     z 删除的结点
     */
    public void remove(T key) {
        RBTNode<T> node;

        if ((node = search(mRoot, key)) != null)
            remove(node);
    }

    /*
     * 销毁红黑树
     */
    private void destroy(RBTNode<T> tree) {
        if (tree==null)
            return ;

        if (tree.left != null)
            destroy(tree.left);
        if (tree.right != null)
            destroy(tree.right);

        tree=null;
    }

    public void clear() {
        destroy(mRoot);
        mRoot = null;
    }

    /*
     * 打印"红黑树"
     *
     * key        -- 节点的键值
     * direction  --  0，表示该节点是根节点;
     *               -1，表示该节点是它的父结点的左孩子;
     *                1，表示该节点是它的父结点的右孩子。
     */
    private void print(RBTNode<T> tree, T key, int direction) {

        if(tree != null) {

            if(direction==0)    // tree是根节点
                System.out.printf("%2d(B) is root\n", tree.key);
            else                // tree是分支节点
                System.out.printf("%2d(%s) is %2d's %6s child\n", tree.key, isRed(tree)?"R":"B", key, direction==1?"right" : "left");

            print(tree.left, tree.key, -1);
            print(tree.right,tree.key,  1);
        }
    }

    public void print() {
        if (mRoot != null)
            print(mRoot, mRoot.key, 0);
    }


```





0/1背包算法思路说一下



01背包问题

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。



用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。

注意f[i][v]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是f[N][V]，而是f[N][0..V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[i][v-1]，这样就可以保证f[N][V]就是最后的答案。至于为什么这样就可以，由你自己来体会了。

优化空间复杂度

for i=1..N
for v=V..0
f[v]=max{f[v],f[v-c[i]]+w[i]};



完全背包问题

有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。



这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<= v}。这跟01背包问题一样有O(N*V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度是超过O(VN)的。

更高效的转化方法是：把第i种物品拆成费用为c[i]*2^k、价值为w[i]*2^k的若干件物品，其中k满足c[i]*2^k<V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。



多重背包问题

有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。



基本算法
这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取 n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f[i][v]=max{f[i-1][v-k*c[i]]+ k*w[i]|0<=k<=n[i]}。复杂度是O(V*∑n[i])。

可用通过转化成01背包降低复杂度：

方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。

算法的复杂度由O(V*∑n[i])改进到O(V*∑log n[i])。



混合三种背包问题
问题
如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？

考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。伪代码如下：

for i=1..N
if 第i件物品是01背包
for v=V..0
f[v]=max{f[v],f[v-c[i]]+w[i]};
else if 第i件物品是完全背包
for v=0..V
f[v]=max{f[v],f[v-c[i]]+w[i]};





动态规划可能会有什么不足





手撕：模拟Linux命令行路径压缩，起初题目看不太懂，然后面试也非常细心地解释了。 

  ../表示上级目录 ./表示当前目录 

  比如 

  /a/b/c/../d -> /a/b/d 

  /a/b/c/././../../e -> /a/e

```java
//用栈
public static String dirCompression(String path){

    if (path==null|| path.length()==0)
        return "";
    String[] dirs=path.split("/");
    Stack stack =new Stack();
    for (int i=0;i<dirs.length;i++){
        if (dirs[i].equals(".")){
            continue;
        }
        else if (dirs[i].equals("..")){
            if (!stack.isEmpty()){
                stack.pop();
            }
        }else {
            stack.push(dirs[i]);
        }
    }

    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()){
        sb.insert(0,stack.pop()+"/");
    }

    return sb.substring(0,sb.length()-1);


}
```



手撕：树的层次遍历，就正常地用BFS写了下来，逻辑没有问题。但后来说我开放的接口不够，考虑的不够。

**遍历技巧一： 数组长度做隔离**

思路：

获取当前的队列的长度length，一次只遍历length个节点，后续加入的元素在下一次循环遍历。

伪代码如下：

```
1 queue =  [node]  // 新建一个队列，并将根节点放入队列
2 while queue.lengh != 0
3     length = queue.length //  获取当前队列的长度
4     while length > 0        // 只弹出length 个节点
5         item = queue.shift // 弹出队列的头部元素
6         do_something(item)    //  操作该节点：比如存入一个数组或者打印
7         queue.push(item.left)  if item.left  // 将左子节点存入队列
8         queue.push(item.right) if item.right  // 将右子节点存入队列
9         length--
```



**遍历技巧二：使用分隔符**

思路

在不同的节点中间加入一个分隔符，遍历发哦分割几点的时候，停止当前遍历。

伪代码如下：

```
1 queue = [node]     // 新建一个队列，并将根节点放入到队列
2 while queue.lengh != 0
3     queue.push "$"    // 将分割符放入队列
4     while(true)           // 做一个无限循环
5            item = queue.shift   // 弹出队列的头部元素
6            break if item == '$'   // 如果当前的节点等于分隔符，说明该层已经遍历到了最右边
7            do_something(item)  //操作该节点
8            queue.push(item.left)  if item.left // 将左子节点存入队列
9            queue.push(item.right)  if item.right // 将右子节点存入队列
```





手写二叉树、数组全排列。

* 递归会造成过深的栈深度
* 考虑重复元素

```java
public class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(nums==null || nums.length==0) return res;
      //判断是否有重复
        boolean[] used = new boolean[nums.length];
        List<Integer> list = new ArrayList<Integer>();
        Arrays.sort(nums);
        dfs(nums, used, list, res);
        return res;
    }

    public void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res){
        if(list.size()==nums.length){
            res.add(new ArrayList<Integer>(list));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(used[i]) continue;
            if(i>0 &&nums[i-1]==nums[i] && !used[i-1]) continue;
            used[i]=true;
            list.add(nums[i]);
            dfs(nums,used,list,res);
            used[i]=false;
            list.remove(list.size()-1);
        }
    }
}
```



撕了一个穿过最少砖头的题，不算难。一个最长回文子串，dp



 最长公共子串 判断两字符串中是否字符相同，顺序不同



两道数组的算法题，很简单，把leetcode数组部分的做做就好



随便写个排序 我写的快排



从数组中查找某个数k 查到返回index 否则返回0



手撕代码:给定一定金额，有三样商品，有多少种买法能恰好花完

手撕代码:字符串s和p，在s中删除最少的字符，使p为s的子串

手撕代码是桶排序

手撕代码 数组中除了两个数只出现了一次，其余都出现了两次，找到这两个数 剑指offer原题

手撕代码，给一个很大的数，比如9534532679，找最大递减数，比如这个例子就是953

手撕单链表的排序，规定用直接插入排序，在原链表修改

手撕代码：剑指offer，转圈剔除学生

如何用数组实现一个环

手撕代码：数组中不重复元素的个数，数组有序，空间复杂度为1

二分查找，写了个递归版的，然后又让写个循环版的。

上来先写一个，求一个二叉树节点的最大值。我用先序遍历写了一个。

然后加强版，求一个二叉树第k大的节点值，我用小顶堆+先序遍历写了一个

.手撕：写一个双向链表结构、写一个双向链表的插入函数







有两个比较大的数组，让求它们的交集。（当时也没有限制说时空复杂度要怎么样）就说你先想想，也可以和我交流。 

  想了一会儿（当时不知道为啥，完全没想到用hash做。。），就说了一个把其中一个排序，再遍历另一个去二分查找的思路。



CAP 和 BASE

CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

## 1.1 一致性（Consistency）

一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。

## 1.2 可用性（Availability）

可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。

## 1.3 分区容错性（Partition tolerance）

分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。



BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。

BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。

## 3.1 基本可用（Basically Available）

基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。

电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。

## 3.2 软状态（ Soft State）

软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。

## 3.3 最终一致性（ Eventual Consistency）

最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。





ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。

ACID和BASE代表了两种截然相反的设计哲学

在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。



 Reids 集群选举，心跳检测

### 心跳检测

在命令传播阶段，**从服务器默认以每秒一次的频率**，向主服务器发送命令：

**REPLCONF ACK <replication_offset>** //replication_offset是从服务器当前的复制偏移量。

心跳检测的作用：检测主服务器的网络连接状态；辅助实现min-slaves选项；检测命令丢失。

检测主从服务器的网络连接状态

通过向主服务器发送INFO replication命令，可以列出从服务器列表，可以看出从最后一次向主发送命令距离现在过了多少秒。

lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有故障。

辅助实现min-slaves选项

Redis可以通过配置**防止主服务器在不安全的情况下执行写命令**；

min-slaves-to-write 3

min-slaves-max-lag 10

上面的配置表示：从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令。这里的延迟值就是上面INFOreplication命令的lag值。

检测命令丢失

如果因为网络故障，主服务器传播给从服务器的**写命令在半路丢失**，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的**复制偏移量**少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。

主服务器向从服务器**补发缺失数据**这一操作的原理和部分重同步操作的原理非常相似，它们的区别在于：补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步操作则在主从服务器断线并重连之后执行。









分库分表，数据库事务，分布式事务





操作系统了解说，说一下你设计操作系统要几个模块。
（磁盘管理  线程管理  IO管理  文件管理）

有没有用过数据库 ， 怎么去连 。 哪几个步骤？ 说一下。 数据库连接池了解吗， 有什么好处？有没有写过复杂sql  游标了解吗



线上的问题，如何去排查， 怎么去看到当前程序运行的状态。

数据库查询慢是什么原因。

gdp怎么来切换线程

讲讲共享内存原理

:进程A和B的地址都是0xabcd123，会不会相互访问，为什么

epoll和select poll的区别，开始讲源码然后讲了一会他让我停了...说可以了

正向代理和反向代理





快排原理

归并排序原理

冒泡排序稳定吗



说下自己对  Zookeeper 的理解已经在项目中是如何应用的，自己扯 ZAB，已经 ZK 在 Dubbo 做注册中心，在 Kafka 中做集群管理，还有分布式锁实现，集群选举 Raft 和 Paxos 区别已经具体的流程

<https://www.cnblogs.com/bangerlee/p/5991417.html>





GC 调优 

项目中用过到的算法和数据结构，讲了下 Redis ZSET 和 蚁群算法