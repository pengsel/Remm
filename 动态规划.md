## 动态规划

### 数字三角形

数字三角形，求输出最大和

```
7
1 2
3 4 5
8 7 6 5
```

直接递归有很多重复计算

避免重复计算，每算出一个就存下来。

递归转成递推(循环)；

空间优化maxSum；直接用D数组的最后一行替换maxSum；



递归->动态规划 步骤：

* 递归有n个参数，就定义一个n维的数组，数组下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值
* 从边界值开始，逐步填充数组，计算递归函数值的逆过程



一般思路：

1. 原问题分解为子问题
   * 相同类似，规模变小
   * 子问题的解求出要保存
2. 确定状态
   * 和子问题相关的各个变量的一组取值，一个状态对应于一个或多个子问题，某个状态的值，指的是所对应的子问题的解；
   * 整个问题的时间复杂度=状态数×每个状态时间。
3. 确定初始状态的值
4. 确定状态转移方程，已知->未知



能用动态规划的问题：

* 最优子结构：问题的最优解所包含的子问题的解也是最优的。
* 无后效性：当前若干个状态一旦确定，此后过程的演变就只和这若干个状态的值有关，与之前怎么演变这若干个状态无关。



### 最长上升子序列

无后效性->以后的事情和如何到达状态有关，则不符合“无后效性”；

* 子问题：以ak为终点的最长上升子序列的长度，求其中最大的。
* 确定状态：
  * 子问题只和一个变量相关
* 状态转移方程：
  * maxLen(k)=max{maxLen(i): 1<=i<k且ai<ak且ak且k!=1}+1

时间复杂度O(n2)



### 递归型

* 优点：直观，容易编写
* 缺点：无法使用滚动数组节省空间，比递推型慢

### 递推型

* 效率高



### 最长公共子序列

难点在于状态的设计

* 状态：maxLen(len1,len2)
* 递推公式：

```
if (s1[i-1]==s2[j-1]){
	maxlen(i,j)=maxLen(i-1,j-1)+1;
}else{
	maxlen(i,j)=max(maxLen(i-1,j),maxLen(i,j-1));
}
```

证明：显而易见，不会比这两个任何一个小

反证法：假设比两个都大



### 最佳加法表达式

* 状态：V(m,n)，在n个数字中插入m个加号所能形成的表达式
* 递推公式：

```
if(m=0){
	V(m,n)=该整数
}else if(n<m+1){
	V(m,n)=无穷
}else{
//num(i,j)表示从i个数到j个数组成的数字
	V(m,n)=min{V(m-1,i)+num(i+1,n)}(i=m...n-1)
}
```

预处理提前算出num(i,j)

时间复杂度：O(mn2)

tips：可能需要使用高精度计算



#### Help Jimmy

子问题:从某块板子下来的时间

递推关系

```
if(板子k左端正下方没有别的板子){
	if((k)>MAX){
		LeftMinTime(k)=无穷;
	}else{
		LeftMinTime(k)=h(k);
	}
}else if(板子k左端正下方的板子编号是m){
	LeftMinTime(k)=h(k)-h(m)+min(LeftMinTime(m)+Lx(k)-Lx(m),
	RightMinTime(m)+Rx(m)-Lx(k));
}
RightMinTime(k)类似
```

需要先将板子按高度排序



#### 滑雪

给定高度矩阵,最长滑雪距离;

L(i,j)表示从(i,j)出发的最长滑行长度,一个点(i,j),如果周围没有比它低的点,L(i,j)=1;

否则:

​	递推公式:L(i,j)等于(i,j)周围四个点中,比(i,j)低,且L值最大的那个L值,再加1

"人人为我"---我是高点,周围有多高,我比它加1

将所有点按高度从小到大排序,每个点的L值都初始化为1,从小到大遍历,每经过一个点(i,j),利用递推公式计算.

"我为人人"---我是低点,由我更新高点,你们比我高,你们加1

从小到大遍历所有点,每经过一个点(i,j),要更新它周围的比它高的点的L值;

```
if H(i+1,j)>H(i,j){
	L(i+1,j)=max(L(i+1,j), L(i,j)+1)
}
```

#### 神奇口袋

枚举,算法复杂度指数级

递归的做法

子问题:从前k种物品选择一些,凑成体积w的做法数目

```
if(w==0)
	V(w,k)=0;
else
	V(w,k)=V(w,k-1)+V(w-a[k],k-1);
```

动规的做法

```
V[i][j];前j种物品凑出体积i的方法数
for(int i=1;i<=N;i++){
	V[0][i]=1;
}
V[0][0]=1;
for(int w=1;w<=40;++w){
	for(int k=1;k<=N;++k){
		V[w][k]=V[w][k-1]
		if(w-a[k]>=0){
			V[w][k]+=V[w-a[k]][k-1];
		}
	}
}
```



#### 背包问题

N件物品,体积M,最大价值

```
F[i][j];表示取前i种物品,使得它们总体积不超过j的最优取法取得的价值总和;
边界:
	if(f[1][j]<=w[1]){
		F[1][j]=a[1];
	}else{
		F[1][j]=0;
	}
递归:
	F[i][j]=max(F[i-1][j],F[i-1][j-w[i]]+d[i])
	
	采用记忆型递归,会需要一个很大的二维数组,由于只用到了正上方一行和上一行左边的某个位置.
	
	从右到左求
	
```



#### 分蛋糕

w,h切成m块,每切一块将其分成两个矩形蛋糕,切的地方必须在整数

要使得最大块的最小



```
ways(w,h,m)被切n刀后,最大的蛋糕的面积最小值
边界条件:
w*h<m+1   INF
m==0      w*h
递推式:
SV 竖着最好结果
SH 横着
ways(w,h,m)=min(SV,SH);
	SV=min(Si, i=1...w-1);Si第一刀左边宽为i的情况下的最好结果
	Si=min{max(ways(i,h,k), ways(w-1,m-1-k)),k=0..m-1}
	
	三重循环
```



Minimum